import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/.pnpm/uuidv7@1.0.2/node_modules/uuidv7/dist/index.js
var DIGITS = "0123456789abcdef";
var UUID = class _UUID {
  /** @param bytes - The 16-byte byte array representation. */
  constructor(bytes) {
    this.bytes = bytes;
  }
  /**
   * Creates an object from the internal representation, a 16-byte byte array
   * containing the binary UUID representation in the big-endian byte order.
   *
   * This method does NOT shallow-copy the argument, and thus the created object
   * holds the reference to the underlying buffer.
   *
   * @throws TypeError if the length of the argument is not 16.
   */
  static ofInner(bytes) {
    if (bytes.length !== 16) {
      throw new TypeError("not 128-bit length");
    } else {
      return new _UUID(bytes);
    }
  }
  /**
   * Builds a byte array from UUIDv7 field values.
   *
   * @param unixTsMs - A 48-bit `unix_ts_ms` field value.
   * @param randA - A 12-bit `rand_a` field value.
   * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.
   * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.
   * @throws RangeError if any field value is out of the specified range.
   */
  static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {
    if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 4095 || randBHi > 1073741823 || randBLo > 4294967295) {
      throw new RangeError("invalid field value");
    }
    const bytes = new Uint8Array(16);
    bytes[0] = unixTsMs / 2 ** 40;
    bytes[1] = unixTsMs / 2 ** 32;
    bytes[2] = unixTsMs / 2 ** 24;
    bytes[3] = unixTsMs / 2 ** 16;
    bytes[4] = unixTsMs / 2 ** 8;
    bytes[5] = unixTsMs;
    bytes[6] = 112 | randA >>> 8;
    bytes[7] = randA;
    bytes[8] = 128 | randBHi >>> 24;
    bytes[9] = randBHi >>> 16;
    bytes[10] = randBHi >>> 8;
    bytes[11] = randBHi;
    bytes[12] = randBLo >>> 24;
    bytes[13] = randBLo >>> 16;
    bytes[14] = randBLo >>> 8;
    bytes[15] = randBLo;
    return new _UUID(bytes);
  }
  /**
   * Builds a byte array from a string representation.
   *
   * This method accepts the following formats:
   *
   * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`
   * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`
   * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`
   * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`
   *
   * Leading and trailing whitespaces represents an error.
   *
   * @throws SyntaxError if the argument could not parse as a valid UUID string.
   */
  static parse(uuid) {
    var _a, _b, _c, _d;
    let hex = void 0;
    switch (uuid.length) {
      case 32:
        hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];
        break;
      case 36:
        hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join("");
        break;
      case 38:
        hex = (_c = /^\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\}$/i.exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join("");
        break;
      case 45:
        hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join("");
        break;
      default:
        break;
    }
    if (hex) {
      const inner = new Uint8Array(16);
      for (let i = 0; i < 16; i += 4) {
        const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);
        inner[i + 0] = n >>> 24;
        inner[i + 1] = n >>> 16;
        inner[i + 2] = n >>> 8;
        inner[i + 3] = n;
      }
      return new _UUID(inner);
    } else {
      throw new SyntaxError("could not parse UUID string");
    }
  }
  /**
   * @returns The 8-4-4-4-12 canonical hexadecimal string representation
   * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).
   */
  toString() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
      if (i === 3 || i === 5 || i === 7 || i === 9) {
        text += "-";
      }
    }
    return text;
  }
  /**
   * @returns The 32-digit hexadecimal representation without hyphens
   * (`0189dcd553117d408db09496a2eef37b`).
   */
  toHex() {
    let text = "";
    for (let i = 0; i < this.bytes.length; i++) {
      text += DIGITS.charAt(this.bytes[i] >>> 4);
      text += DIGITS.charAt(this.bytes[i] & 15);
    }
    return text;
  }
  /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */
  toJSON() {
    return this.toString();
  }
  /**
   * Reports the variant field value of the UUID or, if appropriate, "NIL" or
   * "MAX".
   *
   * For convenience, this method reports "NIL" or "MAX" if `this` represents
   * the Nil or Max UUID, although the Nil and Max UUIDs are technically
   * subsumed under the variants `0b0` and `0b111`, respectively.
   */
  getVariant() {
    const n = this.bytes[8] >>> 4;
    if (n < 0) {
      throw new Error("unreachable");
    } else if (n <= 7) {
      return this.bytes.every((e) => e === 0) ? "NIL" : "VAR_0";
    } else if (n <= 11) {
      return "VAR_10";
    } else if (n <= 13) {
      return "VAR_110";
    } else if (n <= 15) {
      return this.bytes.every((e) => e === 255) ? "MAX" : "VAR_RESERVED";
    } else {
      throw new Error("unreachable");
    }
  }
  /**
   * Returns the version field value of the UUID or `undefined` if the UUID does
   * not have the variant field value of `0b10`.
   */
  getVersion() {
    return this.getVariant() === "VAR_10" ? this.bytes[6] >>> 4 : void 0;
  }
  /** Creates an object from `this`. */
  clone() {
    return new _UUID(this.bytes.slice(0));
  }
  /** Returns true if `this` is equivalent to `other`. */
  equals(other) {
    return this.compareTo(other) === 0;
  }
  /**
   * Returns a negative integer, zero, or positive integer if `this` is less
   * than, equal to, or greater than `other`, respectively.
   */
  compareTo(other) {
    for (let i = 0; i < 16; i++) {
      const diff = this.bytes[i] - other.bytes[i];
      if (diff !== 0) {
        return Math.sign(diff);
      }
    }
    return 0;
  }
};
var V7Generator = class {
  /**
   * Creates a generator object with the default random number generator, or
   * with the specified one if passed as an argument. The specified random
   * number generator should be cryptographically strong and securely seeded.
   */
  constructor(randomNumberGenerator) {
    this.timestamp = 0;
    this.counter = 0;
    this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method resets the
   * generator and returns a new UUID based on the given timestamp, breaking the
   * increasing order of UUIDs.
   *
   * See {@link generateOrAbort} for the other mode of generation and
   * {@link generateOrResetCore} for the low-level primitive.
   */
  generate() {
    return this.generateOrResetCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the current timestamp, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method returns a monotonically increasing UUID by reusing the previous
   * timestamp even if the up-to-date timestamp is smaller than the immediately
   * preceding UUID's. However, when such a clock rollback is considered
   * significant (i.e., by more than ten seconds), this method aborts and
   * returns `undefined` immediately.
   *
   * See {@link generate} for the other mode of generation and
   * {@link generateOrAbortCore} for the low-level primitive.
   */
  generateOrAbort() {
    return this.generateOrAbortCore(Date.now(), 1e4);
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the
   * generator upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generate} except that it takes a custom
   * timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrResetCore(unixTsMs, rollbackAllowance) {
    let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    if (value === void 0) {
      this.timestamp = 0;
      value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);
    }
    return value;
  }
  /**
   * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns
   * `undefined` upon significant timestamp rollback.
   *
   * This method is equivalent to {@link generateOrAbort} except that it takes a
   * custom timestamp and clock rollback allowance.
   *
   * @param rollbackAllowance - The amount of `unixTsMs` rollback that is
   * considered significant. A suggested value is `10_000` (milliseconds).
   * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.
   */
  generateOrAbortCore(unixTsMs, rollbackAllowance) {
    const MAX_COUNTER = 4398046511103;
    if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {
      throw new RangeError("`unixTsMs` must be a 48-bit positive integer");
    } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {
      throw new RangeError("`rollbackAllowance` out of reasonable range");
    }
    if (unixTsMs > this.timestamp) {
      this.timestamp = unixTsMs;
      this.resetCounter();
    } else if (unixTsMs + rollbackAllowance >= this.timestamp) {
      this.counter++;
      if (this.counter > MAX_COUNTER) {
        this.timestamp++;
        this.resetCounter();
      }
    } else {
      return void 0;
    }
    return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & 2 ** 30 - 1, this.random.nextUint32());
  }
  /** Initializes the counter at a 42-bit random integer. */
  resetCounter() {
    this.counter = this.random.nextUint32() * 1024 + (this.random.nextUint32() & 1023);
  }
  /**
   * Generates a new UUIDv4 object utilizing the random number generator inside.
   *
   * @internal
   */
  generateV4() {
    const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);
    bytes[6] = 64 | bytes[6] >>> 4;
    bytes[8] = 128 | bytes[8] >>> 2;
    return UUID.ofInner(bytes);
  }
};
var getDefaultRandom = () => {
  if (typeof crypto !== "undefined" && typeof crypto.getRandomValues !== "undefined") {
    return new BufferedCryptoRandom();
  } else {
    if (typeof UUIDV7_DENY_WEAK_RNG !== "undefined" && UUIDV7_DENY_WEAK_RNG) {
      throw new Error("no cryptographically strong RNG available");
    }
    return {
      nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)
    };
  }
};
var BufferedCryptoRandom = class {
  constructor() {
    this.buffer = new Uint32Array(8);
    this.cursor = 65535;
  }
  nextUint32() {
    if (this.cursor >= this.buffer.length) {
      crypto.getRandomValues(this.buffer);
      this.cursor = 0;
    }
    return this.buffer[this.cursor++];
  }
};
var defaultGenerator;
var uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();
var uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();

// node_modules/.pnpm/isows@1.0.6_ws@8.18.1/node_modules/isows/_esm/utils.js
function getNativeWebSocket() {
  if (typeof WebSocket !== "undefined")
    return WebSocket;
  if (typeof global.WebSocket !== "undefined")
    return global.WebSocket;
  if (typeof window.WebSocket !== "undefined")
    return window.WebSocket;
  if (typeof self.WebSocket !== "undefined")
    return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}

// node_modules/.pnpm/isows@1.0.6_ws@8.18.1/node_modules/isows/_esm/native.js
var WebSocket2 = getNativeWebSocket();

// node_modules/.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/dist/index.mjs
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
};
var Emitter = class {
  constructor({ interceptors } = {}) {
    __publicField(this, "collectable", {});
    __publicField(this, "listeners", {});
    __publicField(this, "interceptors");
    this.interceptors = interceptors ?? {};
  }
  subscribe(event, listener, historic = false) {
    var _a;
    if (this.listeners[event] || (this.listeners[event] = []), !this.isSubscribed(event, listener) && ((_a = this.listeners[event]) == null ? void 0 : _a.push(listener), historic && this.collectable[event])) {
      let buffer = this.collectable[event];
      delete this.collectable[event];
      for (let args of buffer) listener(...args);
    }
  }
  async subscribeOnce(event, historic = false) {
    var _a, _b;
    if (historic && this.collectable[event]) {
      let args = (_a = this.collectable[event]) == null ? void 0 : _a.shift();
      if (((_b = this.collectable[event]) == null ? void 0 : _b.length) === 0 && delete this.collectable[event], args) return args;
    }
    return new Promise((resolve) => {
      let resolved = false, listener = (...args) => {
        resolved || (resolved = true, this.unSubscribe(event, listener), resolve(args));
      };
      this.subscribe(event, listener, false);
    });
  }
  unSubscribe(event, listener) {
    var _a, _b, _c;
    if (this.listeners[event]) {
      let index = (_a = this.listeners[event]) == null ? void 0 : _a.findIndex((v) => v === listener);
      index >= 0 && ((_b = this.listeners[event]) == null ? void 0 : _b.splice(index, 1), ((_c = this.listeners[event]) == null ? void 0 : _c.length) === 0 && delete this.listeners[event]);
    }
  }
  isSubscribed(event, listener) {
    var _a;
    return !!((_a = this.listeners[event]) == null ? void 0 : _a.includes(listener));
  }
  async emit(event, args, collectable = false) {
    var _a, _b;
    let interceptor = this.interceptors[event], computedArgs = interceptor ? await interceptor(...args) : args;
    (collectable && !this.listeners[event] || ((_a = this.listeners[event]) == null ? void 0 : _a.length) === 0) && (this.collectable[event] || (this.collectable[event] = []), (_b = this.collectable[event]) == null ? void 0 : _b.push(args));
    for (let listener of this.listeners[event] ?? []) listener(...computedArgs);
  }
  reset({ collectable, listeners }) {
    if (Array.isArray(collectable)) for (let k of collectable) delete this.collectable[k];
    else typeof collectable == "string" ? delete this.collectable[collectable] : collectable !== false && (this.collectable = {});
    if (Array.isArray(listeners)) for (let k of listeners) delete this.listeners[k];
    else typeof listeners == "string" ? delete this.listeners[listeners] : listeners !== false && (this.listeners = {});
  }
  scanListeners(filter) {
    let listeners = Object.keys(this.listeners);
    return filter && (listeners = listeners.filter(filter)), listeners;
  }
};
var Gap = class {
  constructor(...args) {
    __publicField(this, "args", []);
    this.args = args;
  }
  fill(value) {
    return [this, value];
  }
  hasDefault() {
    return this.args.length === 1;
  }
  get default() {
    return this.args[0];
  }
};
var cbor_exports = {};
__export(cbor_exports, { CborBreak: () => CborBreak, CborError: () => CborError, CborFillMissing: () => CborFillMissing, CborInvalidMajorError: () => CborInvalidMajorError, CborNumberError: () => CborNumberError, CborPartialDisabled: () => CborPartialDisabled, CborRangeError: () => CborRangeError, Encoded: () => Encoded, Gap: () => Gap, POW_2_53: () => POW_2_53, POW_2_64: () => POW_2_64, PartiallyEncoded: () => PartiallyEncoded, Reader: () => Reader, Tagged: () => Tagged, Writer: () => Writer, decode: () => decode, encode: () => encode, infiniteBytes: () => infiniteBytes, partiallyEncodeObject: () => partiallyEncodeObject });
var POW_2_53 = 9007199254740992;
var POW_2_64 = BigInt(18446744073709552e3);
var Encoded = class {
  constructor(encoded) {
    this.encoded = encoded;
  }
};
var SurrealDbError = class extends Error {
};
var NoActiveSocket = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoActiveSocket");
    __publicField(this, "message", "No socket is currently connected to a SurrealDB instance. Please call the .connect() method first!");
  }
};
var NoConnectionDetails = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoConnectionDetails");
    __publicField(this, "message", "No connection details for the HTTP api have been provided. Please call the .connect() method first!");
  }
};
var UnexpectedResponse = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UnexpectedResponse");
    __publicField(this, "message", "The returned response from the SurrealDB instance is in an unexpected format. Unable to process response!");
  }
};
var InvalidURLProvided = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "InvalidURLProvided");
    __publicField(this, "message", "The provided string is either not a URL or is a URL but with an invalid protocol!");
  }
};
var NoURLProvided = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoURLProvided");
    __publicField(this, "message", "Tried to establish a connection while no connection URL was provided");
  }
};
var EngineDisconnected = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "EngineDisconnected");
    __publicField(this, "message", "The engine reported the connection to SurrealDB has dropped");
  }
};
var ReconnectFailed = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ReconnectFailed");
    __publicField(this, "message", "The engine failed to reconnect to SurrealDB");
  }
};
var ReconnectIterationError = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ReconnectIterationError");
    __publicField(this, "message", "The reconnect iterator failed to iterate");
  }
};
var UnexpectedServerResponse = class extends SurrealDbError {
  constructor(response) {
    super();
    __publicField(this, "name", "UnexpectedServerResponse");
    this.response = response;
    this.message = `${response}`;
  }
};
var UnexpectedConnectionError = class extends SurrealDbError {
  constructor(error) {
    super();
    __publicField(this, "name", "UnexpectedConnectionError");
    this.error = error;
    this.message = `${error}`;
  }
};
var UnsupportedEngine = class extends SurrealDbError {
  constructor(engine) {
    super();
    __publicField(this, "name", "UnsupportedEngine");
    __publicField(this, "message", "The engine you are trying to connect to is not supported or configured.");
    this.engine = engine;
  }
};
var FeatureUnavailableForEngine = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "FeatureUnavailableForEngine");
    __publicField(this, "message", "The feature you are trying to use is not available on this engine.");
  }
};
var ConnectionUnavailable = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConnectionUnavailable");
    __publicField(this, "message", "There is no connection available at this moment.");
  }
};
var MissingNamespaceDatabase = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "MissingNamespaceDatabase");
    __publicField(this, "message", "There is no namespace and/or database selected.");
  }
};
var HttpConnectionError = class extends SurrealDbError {
  constructor(message, status, statusText, buffer) {
    super();
    __publicField(this, "name", "HttpConnectionError");
    this.message = message;
    this.status = status;
    this.statusText = statusText;
    this.buffer = buffer;
  }
};
var ResponseError = class extends SurrealDbError {
  constructor(message) {
    super();
    __publicField(this, "name", "ResponseError");
    this.message = message;
  }
};
var NoNamespaceSpecified = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoNamespaceSpecified");
    __publicField(this, "message", "Please specify a namespace to use.");
  }
};
var NoDatabaseSpecified = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoDatabaseSpecified");
    __publicField(this, "message", "Please specify a database to use.");
  }
};
var NoTokenReturned = class extends SurrealDbError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "NoTokenReturned");
    __publicField(this, "message", "Did not receive an authentication token.");
  }
};
var UnsupportedVersion = class extends SurrealDbError {
  constructor(version, supportedRange) {
    super();
    __publicField(this, "name", "UnsupportedVersion");
    __publicField(this, "version");
    __publicField(this, "supportedRange");
    this.version = version, this.supportedRange = supportedRange, this.message = `The version "${version}" reported by the engine is not supported by this library, expected a version that satisfies "${supportedRange}".`;
  }
};
var VersionRetrievalFailure = class extends SurrealDbError {
  constructor(error) {
    super();
    __publicField(this, "name", "VersionRetrievalFailure");
    __publicField(this, "message", "Failed to retrieve remote version. If the server is behind a proxy, make sure it's configured correctly.");
    this.error = error;
  }
};
var CborError = class extends SurrealDbError {
  constructor(message) {
    super();
    __publicField(this, "message");
    this.message = message;
  }
};
var CborNumberError = class extends CborError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "CborNumberError");
  }
};
var CborRangeError = class extends CborError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "CborRangeError");
  }
};
var CborInvalidMajorError = class extends CborError {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "CborInvalidMajorError");
  }
};
var CborBreak = class extends CborError {
  constructor() {
    super("Came across a break which was not intercepted by the decoder");
    __publicField(this, "name", "CborBreak");
  }
};
var CborPartialDisabled = class extends CborError {
  constructor() {
    super("Tried to insert a Gap into a CBOR value, while partial mode is not enabled");
    __publicField(this, "name", "CborPartialDisabled");
  }
};
var CborFillMissing = class extends CborError {
  constructor() {
    super("Fill for a gap is missing, and gap has no default");
    __publicField(this, "name", "CborFillMissing");
  }
};
var Writer = class {
  constructor(byteLength = 256) {
    __publicField(this, "_chunks", []);
    __publicField(this, "_pos", 0);
    __publicField(this, "_buf");
    __publicField(this, "_view");
    __publicField(this, "_byte");
    this.byteLength = byteLength;
    this._buf = new ArrayBuffer(this.byteLength), this._view = new DataView(this._buf), this._byte = new Uint8Array(this._buf);
  }
  chunk(gap) {
    this._chunks.push([this._buf.slice(0, this._pos), gap]), this._buf = new ArrayBuffer(this.byteLength), this._view = new DataView(this._buf), this._byte = new Uint8Array(this._buf), this._pos = 0;
  }
  get chunks() {
    return this._chunks;
  }
  get buffer() {
    return this._buf.slice(0, this._pos);
  }
  claim(length) {
    let pos = this._pos;
    if (this._pos += length, this._pos <= this._buf.byteLength) return pos;
    let newLen = this._buf.byteLength << 1;
    for (; newLen < this._pos; ) newLen <<= 1;
    if (newLen > this._buf.byteLength) {
      let oldb = this._byte;
      this._buf = new ArrayBuffer(newLen), this._view = new DataView(this._buf), this._byte = new Uint8Array(this._buf), this._byte.set(oldb);
    }
    return pos;
  }
  writeUint8(value) {
    let pos = this.claim(1);
    this._view.setUint8(pos, value);
  }
  writeUint16(value) {
    let pos = this.claim(2);
    this._view.setUint16(pos, value);
  }
  writeUint32(value) {
    let pos = this.claim(4);
    this._view.setUint32(pos, value);
  }
  writeUint64(value) {
    let pos = this.claim(8);
    this._view.setBigUint64(pos, value);
  }
  writeUint8Array(data) {
    if (data.byteLength === 0) return;
    let pos = this.claim(data.byteLength);
    this._byte.set(data, pos);
  }
  writeArrayBuffer(data) {
    data.byteLength !== 0 && this.writeUint8Array(new Uint8Array(data));
  }
  writePartiallyEncoded(data) {
    for (let [buf, gap] of data.chunks) this.writeArrayBuffer(buf), this.chunk(gap);
    this.writeArrayBuffer(data.end);
  }
  writeFloat32(value) {
    let pos = this.claim(4);
    this._view.setFloat32(pos, value);
  }
  writeFloat64(value) {
    let pos = this.claim(8);
    this._view.setFloat64(pos, value);
  }
  writeMajor(type, length) {
    let base = type << 5;
    length < 24 ? this.writeUint8(base + Number(length)) : length < 256 ? (this.writeUint8(base + 24), this.writeUint8(Number(length))) : length < 65536 ? (this.writeUint8(base + 25), this.writeUint16(Number(length))) : length < 4294967296 ? (this.writeUint8(base + 26), this.writeUint32(Number(length))) : (this.writeUint8(base + 27), this.writeUint64(BigInt(length)));
  }
  output(partial, replacer2) {
    return partial ? new PartiallyEncoded(this._chunks, this.buffer, replacer2) : this.buffer;
  }
};
var PartiallyEncoded = class {
  constructor(chunks, end, replacer2) {
    this.chunks = chunks;
    this.end = end;
    this.replacer = replacer2;
  }
  build(fills, partial) {
    let writer = new Writer(), map = new Map(fills);
    for (let [buffer, gap] of this.chunks) {
      let hasValue = map.has(gap) || gap.hasDefault();
      if (!partial && !hasValue) throw new CborFillMissing();
      if (writer.writeArrayBuffer(buffer), hasValue) {
        let data = map.get(gap) ?? gap.default;
        encode(data, { writer, replacer: this.replacer });
      } else writer.chunk(gap);
    }
    return writer.writeArrayBuffer(this.end), writer.output(!!partial, this.replacer);
  }
};
function partiallyEncodeObject(object, options) {
  return Object.fromEntries(Object.entries(object).map(([k, v]) => [k, encode(v, { ...options, partial: true })]));
}
var Tagged = class {
  constructor(tag, value) {
    this.tag = tag;
    this.value = value;
  }
};
var textEncoder;
function encode(input, options = {}) {
  let w = options.writer ?? new Writer(), fillsMap = new Map(options.fills ?? []);
  function inner(input2) {
    let value = options.replacer ? options.replacer(input2) : input2;
    if (value === void 0) return w.writeUint8(247);
    if (value === null) return w.writeUint8(246);
    if (value === true) return w.writeUint8(245);
    if (value === false) return w.writeUint8(244);
    switch (typeof value) {
      case "number": {
        if (Number.isInteger(value)) if (value >= 0 && value <= 9007199254740992) w.writeMajor(0, value);
        else if (value < 0 && value >= -9007199254740992) w.writeMajor(1, -(value + 1));
        else throw new CborNumberError("Number too big to be encoded");
        else w.writeUint8(251), w.writeFloat64(value);
        return;
      }
      case "bigint": {
        if (value >= 0 && value < POW_2_64) w.writeMajor(0, value);
        else if (value <= 0 && value >= -POW_2_64) w.writeMajor(1, -(value + 1n));
        else throw new CborNumberError("BigInt too big to be encoded");
        return;
      }
      case "string": {
        textEncoder ?? (textEncoder = new TextEncoder());
        let encoded = textEncoder.encode(value);
        w.writeMajor(3, encoded.byteLength), w.writeUint8Array(encoded);
        return;
      }
      default: {
        if (Array.isArray(value)) {
          w.writeMajor(4, value.length);
          for (let v of value) inner(v);
          return;
        }
        if (value instanceof Tagged) {
          w.writeMajor(6, value.tag), inner(value.value);
          return;
        }
        if (value instanceof Encoded) {
          w.writeArrayBuffer(value.encoded);
          return;
        }
        if (value instanceof Gap) {
          if (fillsMap.has(value)) inner(fillsMap.get(value));
          else {
            if (!options.partial) throw new CborPartialDisabled();
            w.chunk(value);
          }
          return;
        }
        if (value instanceof PartiallyEncoded) {
          let res = value.build(options.fills ?? [], options.partial);
          options.partial ? w.writePartiallyEncoded(res) : w.writeArrayBuffer(res);
          return;
        }
        if (value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Uint32Array || value instanceof Int8Array || value instanceof Int16Array || value instanceof Int32Array || value instanceof Float32Array || value instanceof Float64Array || value instanceof ArrayBuffer) {
          let v = new Uint8Array(value);
          w.writeMajor(2, v.byteLength), w.writeUint8Array(v);
          return;
        }
        let entries = value instanceof Map ? Array.from(value.entries()) : Object.entries(value);
        w.writeMajor(5, entries.length);
        for (let v of entries.flat()) inner(v);
      }
    }
  }
  return inner(input), w.output(!!options.partial, options.replacer);
}
var Reader = class {
  constructor(buffer) {
    __publicField(this, "_buf");
    __publicField(this, "_view");
    __publicField(this, "_byte");
    __publicField(this, "_pos", 0);
    this._buf = new ArrayBuffer(buffer.byteLength), this._view = new DataView(this._buf), this._byte = new Uint8Array(this._buf), this._byte.set(new Uint8Array(buffer));
  }
  read(amount, res) {
    return this._pos += amount, res;
  }
  readUint8() {
    try {
      return this.read(1, this._view.getUint8(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readUint16() {
    try {
      return this.read(2, this._view.getUint16(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readUint32() {
    try {
      return this.read(4, this._view.getUint32(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readUint64() {
    try {
      return this.read(8, this._view.getBigUint64(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readFloat16() {
    let bytes = this.readUint16(), s2 = (bytes & 32768) >> 15, e = (bytes & 31744) >> 10, f2 = bytes & 1023;
    return e === 0 ? (s2 ? -1 : 1) * 2 ** -14 * (f2 / 2 ** 10) : e === 31 ? f2 ? Number.NaN : (s2 ? -1 : 1) * Number.POSITIVE_INFINITY : (s2 ? -1 : 1) * 2 ** (e - 15) * (1 + f2 / 2 ** 10);
  }
  readFloat32() {
    try {
      return this.read(4, this._view.getFloat32(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readFloat64() {
    try {
      return this.read(8, this._view.getFloat64(this._pos));
    } catch (e) {
      throw e instanceof RangeError ? new CborRangeError(e.message) : e;
    }
  }
  readBytes(amount) {
    let available = this._byte.length - this._pos;
    if (available < amount) throw new CborRangeError(`The argument must be between 0 and ${available}`);
    return this.read(amount, this._byte.slice(this._pos, this._pos + amount));
  }
  readMajor() {
    let byte = this.readUint8(), major = byte >> 5;
    if (major < 0 || major > 7) throw new CborInvalidMajorError("Received invalid major type");
    return [major, byte & 31];
  }
  readMajorLength(length) {
    if (length <= 23) return length;
    switch (length) {
      case 24:
        return this.readUint8();
      case 25:
        return this.readUint16();
      case 26:
        return this.readUint32();
      case 27: {
        let read = this.readUint64();
        return read > 9007199254740992 ? read : Number(read);
      }
    }
    throw new CborRangeError("Expected a final length");
  }
};
function infiniteBytes(r2, forMajor) {
  let w = new Writer();
  for (; ; ) {
    let [major, len] = r2.readMajor();
    if (major === 7 && len === 31) break;
    if (major !== forMajor) throw new CborInvalidMajorError(`Expected a resource of the same major (${forMajor}) while processing an infinite resource`);
    if (len === 31) throw new CborRangeError("Expected a finite resource while processing an infinite resource");
    w.writeUint8Array(r2.readBytes(Number(r2.readMajorLength(len))));
  }
  return w.buffer;
}
var textDecoder;
function decode(input, options = {}) {
  let r2 = input instanceof Reader ? input : new Reader(input);
  function inner() {
    let [major, len] = r2.readMajor();
    switch (major) {
      case 0:
        return r2.readMajorLength(len);
      case 1: {
        let l = r2.readMajorLength(len);
        return typeof l == "bigint" ? -(l + 1n) : -(l + 1);
      }
      case 2:
        return len === 31 ? infiniteBytes(r2, 2) : r2.readBytes(Number(r2.readMajorLength(len))).buffer;
      case 3: {
        let encoded = len === 31 ? infiniteBytes(r2, 3) : r2.readBytes(Number(r2.readMajorLength(len)));
        return textDecoder ?? (textDecoder = new TextDecoder()), textDecoder.decode(encoded);
      }
      case 4: {
        if (len === 31) {
          let arr2 = [];
          for (; ; ) try {
            arr2.push(decode2());
          } catch (e) {
            if (e instanceof CborBreak) break;
            throw e;
          }
          return arr2;
        }
        let l = r2.readMajorLength(len), arr = Array(l);
        for (let i = 0; i < l; i++) arr[i] = decode2();
        return arr;
      }
      case 5: {
        let entries = [];
        if (len === 31) for (; ; ) {
          let key;
          try {
            key = decode2();
          } catch (e) {
            if (e instanceof CborBreak) break;
            throw e;
          }
          let value = decode2();
          entries.push([key, value]);
        }
        else {
          let l = r2.readMajorLength(len);
          for (let i = 0; i < l; i++) {
            let key = decode2(), value = decode2();
            entries[i] = [key, value];
          }
        }
        return options.map === "map" ? new Map(entries) : Object.fromEntries(entries);
      }
      case 6: {
        let tag = r2.readMajorLength(len), value = decode2();
        return new Tagged(tag, value);
      }
      case 7:
        switch (len) {
          case 20:
            return false;
          case 21:
            return true;
          case 22:
            return null;
          case 23:
            return;
          case 25:
            return r2.readFloat16();
          case 26:
            return r2.readFloat32();
          case 27:
            return r2.readFloat64();
          case 31:
            throw new CborBreak();
        }
    }
    throw new CborInvalidMajorError(`Unable to decode value with major tag ${major}`);
  }
  function decode2() {
    return options.replacer ? options.replacer(inner()) : inner();
  }
  return decode2();
}
function dateToCborCustomDate(date) {
  let s2 = Math.floor(date.getTime() / 1e3), ms = date.getTime() - s2 * 1e3;
  return [s2, ms * 1e6];
}
function cborCustomDateToDate([s2, ns]) {
  let date = /* @__PURE__ */ new Date(0);
  return date.setUTCSeconds(Number(s2)), date.setMilliseconds(Math.floor(Number(ns) / 1e6)), date;
}
var Value = class {
};
var Decimal = class _Decimal extends Value {
  constructor(decimal) {
    super();
    __publicField(this, "decimal");
    this.decimal = decimal.toString();
  }
  equals(other) {
    return other instanceof _Decimal ? this.decimal === other.decimal : false;
  }
  toString() {
    return this.decimal;
  }
  toJSON() {
    return this.decimal;
  }
};
var millisecond = 1;
var microsecond = millisecond / 1e3;
var nanosecond = microsecond / 1e3;
var second = 1e3 * millisecond;
var minute = 60 * second;
var hour = 60 * minute;
var day = 24 * hour;
var week = 7 * day;
var units = /* @__PURE__ */ new Map([["ns", nanosecond], ["µs", microsecond], ["μs", microsecond], ["us", microsecond], ["ms", millisecond], ["s", second], ["m", minute], ["h", hour], ["d", day], ["w", week]]);
var unitsReverse = Array.from(units).reduce((map, [unit, size]) => (map.set(size, unit), map), /* @__PURE__ */ new Map());
var durationPartRegex = new RegExp(`^(\\d+)(${Array.from(units.keys()).join("|")})`);
var Duration = class _Duration extends Value {
  constructor(input) {
    super();
    __publicField(this, "_milliseconds");
    input instanceof _Duration ? this._milliseconds = input._milliseconds : typeof input == "string" ? this._milliseconds = _Duration.parseString(input) : this._milliseconds = input;
  }
  static fromCompact([s2, ns]) {
    s2 = s2 ?? 0, ns = ns ?? 0;
    let ms = s2 * 1e3 + ns / 1e6;
    return new _Duration(ms);
  }
  equals(other) {
    return other instanceof _Duration ? this._milliseconds === other._milliseconds : false;
  }
  toCompact() {
    let s2 = Math.floor(this._milliseconds / 1e3), ns = Math.floor((this._milliseconds - s2 * 1e3) * 1e6);
    return ns > 0 ? [s2, ns] : s2 > 0 ? [s2] : [];
  }
  toString() {
    let left = this._milliseconds, result = "";
    function scrap(size) {
      let num = Math.floor(left / size);
      return num > 0 && (left = left % size), num;
    }
    for (let [size, unit] of Array.from(unitsReverse).reverse()) {
      let scrapped = scrap(size);
      scrapped > 0 && (result += `${scrapped}${unit}`);
    }
    return result;
  }
  toJSON() {
    return this.toString();
  }
  static parseString(input) {
    let ms = 0, left = input;
    for (; left !== ""; ) {
      let match = left.match(durationPartRegex);
      if (match) {
        let amount = Number.parseInt(match[1]), factor = units.get(match[2]);
        if (factor === void 0) throw new SurrealDbError(`Invalid duration unit: ${match[2]}`);
        ms += amount * factor, left = left.slice(match[0].length);
        continue;
      }
      throw new SurrealDbError("Could not match a next duration part");
    }
    return ms;
  }
  static nanoseconds(nanoseconds) {
    return new _Duration(Math.floor(nanoseconds * nanosecond));
  }
  static microseconds(microseconds) {
    return new _Duration(Math.floor(microseconds * microsecond));
  }
  static milliseconds(milliseconds) {
    return new _Duration(milliseconds);
  }
  static seconds(seconds) {
    return new _Duration(seconds * second);
  }
  static minutes(minutes) {
    return new _Duration(minutes * minute);
  }
  static hours(hours) {
    return new _Duration(hours * hour);
  }
  static days(days) {
    return new _Duration(days * day);
  }
  static weeks(weeks) {
    return new _Duration(weeks * week);
  }
  get microseconds() {
    return Math.floor(this._milliseconds / microsecond);
  }
  get nanoseconds() {
    return Math.floor(this._milliseconds / nanosecond);
  }
  get milliseconds() {
    return Math.floor(this._milliseconds);
  }
  get seconds() {
    return Math.floor(this._milliseconds / second);
  }
  get minutes() {
    return Math.floor(this._milliseconds / minute);
  }
  get hours() {
    return Math.floor(this._milliseconds / hour);
  }
  get days() {
    return Math.floor(this._milliseconds / day);
  }
  get weeks() {
    return Math.floor(this._milliseconds / week);
  }
};
var Future = class _Future extends Value {
  constructor(inner) {
    super();
    this.inner = inner;
  }
  equals(other) {
    return other instanceof _Future ? this.inner === other.inner : false;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return `<future> ${this.inner}`;
  }
};
var Geometry = class _Geometry extends Value {
  equals(other) {
    return other instanceof _Geometry ? this.is(other) : false;
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};
function f(num) {
  return num instanceof Decimal ? Number.parseFloat(num.decimal) : num;
}
var GeometryPoint = class _GeometryPoint extends Geometry {
  constructor(point) {
    super();
    __publicField(this, "point");
    point instanceof _GeometryPoint ? this.point = point.clone().point : this.point = [f(point[0]), f(point[1])];
  }
  toJSON() {
    return { type: "Point", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.point;
  }
  is(geometry) {
    return geometry instanceof _GeometryPoint ? this.point[0] === geometry.point[0] && this.point[1] === geometry.point[1] : false;
  }
  clone() {
    return new _GeometryPoint([...this.point]);
  }
};
var GeometryLine = class _GeometryLine extends Geometry {
  constructor(line) {
    super();
    __publicField(this, "line");
    this.line = line instanceof _GeometryLine ? line.clone().line : line;
  }
  toJSON() {
    return { type: "LineString", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.line.map((g) => g.coordinates);
  }
  close() {
    this.line[0].is(this.line.at(-1)) || this.line.push(this.line[0]);
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryLine) || this.line.length !== geometry.line.length) return false;
    for (let i = 0; i < this.line.length; i++) if (!this.line[i].is(geometry.line[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryLine(this.line.map((p) => p.clone()));
  }
};
var GeometryPolygon = class _GeometryPolygon extends Geometry {
  constructor(polygon) {
    super();
    __publicField(this, "polygon");
    this.polygon = polygon instanceof _GeometryPolygon ? polygon.clone().polygon : polygon.map((l) => {
      let line = l.clone();
      return line.close(), line;
    });
  }
  toJSON() {
    return { type: "Polygon", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.polygon.map((g) => g.coordinates);
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryPolygon) || this.polygon.length !== geometry.polygon.length) return false;
    for (let i = 0; i < this.polygon.length; i++) if (!this.polygon[i].is(geometry.polygon[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryPolygon(this.polygon.map((p) => p.clone()));
  }
};
var GeometryMultiPoint = class _GeometryMultiPoint extends Geometry {
  constructor(points) {
    super();
    __publicField(this, "points");
    this.points = points instanceof _GeometryMultiPoint ? points.points : points;
  }
  toJSON() {
    return { type: "MultiPoint", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.points.map((g) => g.coordinates);
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryMultiPoint) || this.points.length !== geometry.points.length) return false;
    for (let i = 0; i < this.points.length; i++) if (!this.points[i].is(geometry.points[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryMultiPoint(this.points.map((p) => p.clone()));
  }
};
var GeometryMultiLine = class _GeometryMultiLine extends Geometry {
  constructor(lines) {
    super();
    __publicField(this, "lines");
    this.lines = lines instanceof _GeometryMultiLine ? lines.lines : lines;
  }
  toJSON() {
    return { type: "MultiLineString", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.lines.map((g) => g.coordinates);
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryMultiLine) || this.lines.length !== geometry.lines.length) return false;
    for (let i = 0; i < this.lines.length; i++) if (!this.lines[i].is(geometry.lines[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryMultiLine(this.lines.map((p) => p.clone()));
  }
};
var GeometryMultiPolygon = class _GeometryMultiPolygon extends Geometry {
  constructor(polygons) {
    super();
    __publicField(this, "polygons");
    this.polygons = polygons instanceof _GeometryMultiPolygon ? polygons.polygons : polygons;
  }
  toJSON() {
    return { type: "MultiPolygon", coordinates: this.coordinates };
  }
  get coordinates() {
    return this.polygons.map((g) => g.coordinates);
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryMultiPolygon) || this.polygons.length !== geometry.polygons.length) return false;
    for (let i = 0; i < this.polygons.length; i++) if (!this.polygons[i].is(geometry.polygons[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryMultiPolygon(this.polygons.map((p) => p.clone()));
  }
};
var GeometryCollection = class _GeometryCollection extends Geometry {
  constructor(collection) {
    super();
    __publicField(this, "collection");
    this.collection = collection instanceof _GeometryCollection ? collection.collection : collection;
  }
  toJSON() {
    return { type: "GeometryCollection", geometries: this.geometries };
  }
  get geometries() {
    return this.collection.map((g) => g.toJSON());
  }
  is(geometry) {
    if (!(geometry instanceof _GeometryCollection) || this.collection.length !== geometry.collection.length) return false;
    for (let i = 0; i < this.collection.length; i++) if (!this.collection[i].is(geometry.collection[i])) return false;
    return true;
  }
  clone() {
    return new _GeometryCollection(this.collection.map((p) => p.clone()));
  }
};
function equals(x, y) {
  if (Object.is(x, y)) return true;
  if (x instanceof Date && y instanceof Date) return x.getTime() === y.getTime();
  if (x instanceof RegExp && y instanceof RegExp) return x.toString() === y.toString();
  if (x instanceof Value && y instanceof Value) return x.equals(y);
  if (typeof x != "object" || x === null || typeof y != "object" || y === null) return false;
  let keysX = Reflect.ownKeys(x), keysY = Reflect.ownKeys(y);
  if (keysX.length !== keysY.length) return false;
  for (let i = 0; i < keysX.length; i++) if (!Reflect.has(y, keysX[i]) || !equals(x[keysX[i]], y[keysX[i]])) return false;
  return true;
}
var MAX_i64 = 9223372036854775807n;
function escapeIdent(str) {
  if (isOnlyNumbers(str)) return `⟨${str}⟩`;
  if (str === "") return "⟨⟩";
  let code, i, len;
  for (i = 0, len = str.length; i < len; i++) if (code = str.charCodeAt(i), !(code > 47 && code < 58) && !(code > 64 && code < 91) && !(code > 96 && code < 123) && code !== 95) return `⟨${str.replaceAll("⟩", "\\⟩")}⟩`;
  return str;
}
function escape_ident(str) {
  return escapeIdent(str);
}
function escapeNumber(num) {
  return num <= MAX_i64 ? num.toString() : `⟨${num}⟩`;
}
function isOnlyNumbers(str) {
  return /^\d+$/.test(str.replace(/_/g, ""));
}
var Uuid = class _Uuid extends Value {
  constructor(uuid) {
    super();
    __publicField(this, "inner");
    uuid instanceof ArrayBuffer ? this.inner = UUID.ofInner(new Uint8Array(uuid)) : uuid instanceof Uint8Array ? this.inner = UUID.ofInner(uuid) : uuid instanceof _Uuid ? this.inner = uuid.inner : uuid instanceof UUID ? this.inner = uuid : this.inner = UUID.parse(uuid);
  }
  equals(other) {
    return other instanceof _Uuid ? this.inner.equals(other.inner) : false;
  }
  toString() {
    return this.inner.toString();
  }
  toJSON() {
    return this.inner.toString();
  }
  toUint8Array() {
    return this.inner.bytes;
  }
  toBuffer() {
    return this.inner.bytes.buffer;
  }
  static v4() {
    return new _Uuid(uuidv4obj());
  }
  static v7() {
    return new _Uuid(uuidv7obj());
  }
};
var RecordId = class _RecordId extends Value {
  constructor(tb, id2) {
    super();
    __publicField(this, "tb");
    __publicField(this, "id");
    if (typeof tb != "string") throw new SurrealDbError("TB part is not valid");
    if (!isValidIdPart(id2)) throw new SurrealDbError("ID part is not valid");
    this.tb = tb, this.id = id2;
  }
  equals(other) {
    return other instanceof _RecordId ? this.tb === other.tb && equals(this.id, other.id) : false;
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    let tb = escapeIdent(this.tb), id2 = escapeIdPart(this.id);
    return `${tb}:${id2}`;
  }
};
var StringRecordId = class _StringRecordId extends Value {
  constructor(rid) {
    super();
    __publicField(this, "rid");
    if (rid instanceof _StringRecordId) this.rid = rid.rid;
    else if (rid instanceof RecordId) this.rid = rid.toString();
    else if (typeof rid == "string") this.rid = rid;
    else throw new SurrealDbError("String Record ID must be a string");
  }
  equals(other) {
    return other instanceof _StringRecordId ? this.rid === other.rid : false;
  }
  toJSON() {
    return this.rid;
  }
  toString() {
    return this.rid;
  }
};
function isValidIdPart(v) {
  if (v instanceof Uuid) return true;
  switch (typeof v) {
    case "string":
    case "number":
    case "bigint":
      return true;
    case "object":
      return Array.isArray(v) || v !== null;
    default:
      return false;
  }
}
function escapeIdPart(id2) {
  return id2 instanceof Uuid ? `u"${id2}"` : typeof id2 == "string" ? escapeIdent(id2) : typeof id2 == "bigint" || typeof id2 == "number" ? escapeNumber(id2) : toSurrealqlString(id2);
}
var Table = class _Table extends Value {
  constructor(tb) {
    super();
    __publicField(this, "tb");
    if (typeof tb != "string") throw new SurrealDbError("Table must be a string");
    this.tb = tb;
  }
  equals(other) {
    return other instanceof _Table ? this.tb === other.tb : false;
  }
  toJSON() {
    return this.tb;
  }
  toString() {
    return this.tb;
  }
};
function toSurrealqlString(input) {
  if (typeof input == "string") return `s${JSON.stringify(input)}`;
  if (input === null) return "NULL";
  if (input === void 0) return "NONE";
  if (typeof input == "object") {
    if (input instanceof Date) return `d${JSON.stringify(input.toISOString())}`;
    if (input instanceof Uuid) return `u${JSON.stringify(input.toString())}`;
    if (input instanceof RecordId || input instanceof StringRecordId) return `r${JSON.stringify(input.toString())}`;
    if (input instanceof Geometry) return toSurrealqlString(input.toJSON());
    if (input instanceof Decimal || input instanceof Duration || input instanceof Future || input instanceof Range || input instanceof Table) return input.toJSON();
    switch (Object.getPrototypeOf(input)) {
      case Object.prototype: {
        let output2 = "{ ", entries = Object.entries(input);
        for (let [i, [k, v]] of entries.entries()) output2 += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`, i < entries.length - 1 && (output2 += ", ");
        return output2 += " }", output2;
      }
      case Map.prototype: {
        let output2 = "{ ", entries = Array.from(input.entries());
        for (let [i, [k, v]] of entries.entries()) output2 += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`, i < entries.length - 1 && (output2 += ", ");
        return output2 += " }", output2;
      }
      case Array.prototype:
        return `[ ${input.map(toSurrealqlString).join(", ")} ]`;
      case Set.prototype:
        return `[ ${[...new Set([...input].map(toSurrealqlString))].join(", ")} ]`;
    }
  }
  return `${input}`;
}
var Range = class _Range extends Value {
  constructor(beg, end) {
    super();
    this.beg = beg;
    this.end = end;
  }
  equals(other) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return !(other instanceof _Range) || ((_a = this.beg) == null ? void 0 : _a.constructor) !== ((_b = other.beg) == null ? void 0 : _b.constructor) || ((_c = this.end) == null ? void 0 : _c.constructor) !== ((_d = other.end) == null ? void 0 : _d.constructor) ? false : equals((_e = this.beg) == null ? void 0 : _e.value, (_f = other.beg) == null ? void 0 : _f.value) && equals((_g = this.end) == null ? void 0 : _g.value, (_h = other.end) == null ? void 0 : _h.value);
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    let beg = escapeRangeBound(this.beg), end = escapeRangeBound(this.end);
    return `${beg}${getRangeJoin(this.beg, this.end)}${end}`;
  }
};
var BoundIncluded = class {
  constructor(value) {
    this.value = value;
  }
};
var BoundExcluded = class {
  constructor(value) {
    this.value = value;
  }
};
var RecordIdRange = class _RecordIdRange extends Value {
  constructor(tb, beg, end) {
    super();
    this.tb = tb;
    this.beg = beg;
    this.end = end;
    if (typeof tb != "string") throw new SurrealDbError("TB part is not valid");
    if (!isValidIdBound(beg)) throw new SurrealDbError("Beg part is not valid");
    if (!isValidIdBound(end)) throw new SurrealDbError("End part is not valid");
  }
  equals(other) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return !(other instanceof _RecordIdRange) || ((_a = this.beg) == null ? void 0 : _a.constructor) !== ((_b = other.beg) == null ? void 0 : _b.constructor) || ((_c = this.end) == null ? void 0 : _c.constructor) !== ((_d = other.end) == null ? void 0 : _d.constructor) ? false : this.tb === other.tb && equals((_e = this.beg) == null ? void 0 : _e.value, (_f = other.beg) == null ? void 0 : _f.value) && equals((_g = this.end) == null ? void 0 : _g.value, (_h = other.end) == null ? void 0 : _h.value);
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    let tb = escapeIdent(this.tb), beg = escapeIdBound(this.beg), end = escapeIdBound(this.end);
    return `${tb}:${beg}${getRangeJoin(this.beg, this.end)}${end}`;
  }
};
function getRangeJoin(beg, end) {
  let output2 = "";
  return beg instanceof BoundExcluded && (output2 += ">"), output2 += "..", end instanceof BoundIncluded && (output2 += "="), output2;
}
function isValidIdBound(bound) {
  return bound instanceof BoundIncluded || bound instanceof BoundExcluded ? isValidIdPart(bound.value) : true;
}
function escapeIdBound(bound) {
  return bound instanceof BoundIncluded || bound instanceof BoundExcluded ? escapeIdPart(bound.value) : "";
}
function escapeRangeBound(bound) {
  if (bound === void 0) return "";
  let value = bound.value;
  return bound instanceof Range ? `(${toSurrealqlString(value)})` : toSurrealqlString(value);
}
function rangeToCbor([beg, end]) {
  function encodeBound(bound) {
    return bound instanceof BoundIncluded ? new Tagged(TAG_BOUND_INCLUDED, bound.value) : bound instanceof BoundExcluded ? new Tagged(TAG_BOUND_EXCLUDED, bound.value) : null;
  }
  return [encodeBound(beg), encodeBound(end)];
}
function cborToRange(range) {
  function decodeBound(bound) {
    if (bound !== null) {
      if (bound.tag === TAG_BOUND_INCLUDED) return new BoundIncluded(bound.value);
      if (bound.tag === TAG_BOUND_EXCLUDED) return new BoundExcluded(bound.value);
      throw new SurrealDbError("Invalid bound tag");
    }
  }
  return [decodeBound(range[0]), decodeBound(range[1])];
}
var TAG_SPEC_DATETIME = 0;
var TAG_SPEC_UUID = 37;
var TAG_NONE = 6;
var TAG_TABLE = 7;
var TAG_RECORDID = 8;
var TAG_STRING_UUID = 9;
var TAG_STRING_DECIMAL = 10;
var TAG_CUSTOM_DATETIME = 12;
var TAG_STRING_DURATION = 13;
var TAG_CUSTOM_DURATION = 14;
var TAG_FUTURE = 15;
var TAG_RANGE = 49;
var TAG_BOUND_INCLUDED = 50;
var TAG_BOUND_EXCLUDED = 51;
var TAG_GEOMETRY_POINT = 88;
var TAG_GEOMETRY_LINE = 89;
var TAG_GEOMETRY_POLYGON = 90;
var TAG_GEOMETRY_MULTIPOINT = 91;
var TAG_GEOMETRY_MULTILINE = 92;
var TAG_GEOMETRY_MULTIPOLYGON = 93;
var TAG_GEOMETRY_COLLECTION = 94;
var replacer = { encode(v) {
  return v instanceof Date ? new Tagged(TAG_CUSTOM_DATETIME, dateToCborCustomDate(v)) : v === void 0 ? new Tagged(TAG_NONE, null) : v instanceof Uuid ? new Tagged(TAG_SPEC_UUID, v.toBuffer()) : v instanceof Decimal ? new Tagged(TAG_STRING_DECIMAL, v.toString()) : v instanceof Duration ? new Tagged(TAG_CUSTOM_DURATION, v.toCompact()) : v instanceof RecordId ? new Tagged(TAG_RECORDID, [v.tb, v.id]) : v instanceof StringRecordId ? new Tagged(TAG_RECORDID, v.rid) : v instanceof RecordIdRange ? new Tagged(TAG_RECORDID, [v.tb, new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end]))]) : v instanceof Table ? new Tagged(TAG_TABLE, v.tb) : v instanceof Future ? new Tagged(TAG_FUTURE, v.inner) : v instanceof Range ? new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end])) : v instanceof GeometryPoint ? new Tagged(TAG_GEOMETRY_POINT, v.point) : v instanceof GeometryLine ? new Tagged(TAG_GEOMETRY_LINE, v.line) : v instanceof GeometryPolygon ? new Tagged(TAG_GEOMETRY_POLYGON, v.polygon) : v instanceof GeometryMultiPoint ? new Tagged(TAG_GEOMETRY_MULTIPOINT, v.points) : v instanceof GeometryMultiLine ? new Tagged(TAG_GEOMETRY_MULTILINE, v.lines) : v instanceof GeometryMultiPolygon ? new Tagged(TAG_GEOMETRY_MULTIPOLYGON, v.polygons) : v instanceof GeometryCollection ? new Tagged(TAG_GEOMETRY_COLLECTION, v.collection) : v;
}, decode(v) {
  if (!(v instanceof Tagged)) return v;
  switch (v.tag) {
    case TAG_SPEC_DATETIME:
      return new Date(v.value);
    case TAG_SPEC_UUID:
    case TAG_STRING_UUID:
      return new Uuid(v.value);
    case TAG_CUSTOM_DATETIME:
      return cborCustomDateToDate(v.value);
    case TAG_NONE:
      return;
    case TAG_STRING_DECIMAL:
      return new Decimal(v.value);
    case TAG_STRING_DURATION:
      return new Duration(v.value);
    case TAG_CUSTOM_DURATION:
      return Duration.fromCompact(v.value);
    case TAG_TABLE:
      return new Table(v.value);
    case TAG_FUTURE:
      return new Future(v.value);
    case TAG_RANGE:
      return new Range(...cborToRange(v.value));
    case TAG_RECORDID:
      return v.value[1] instanceof Range ? new RecordIdRange(v.value[0], v.value[1].beg, v.value[1].end) : new RecordId(v.value[0], v.value[1]);
    case TAG_GEOMETRY_POINT:
      return new GeometryPoint(v.value);
    case TAG_GEOMETRY_LINE:
      return new GeometryLine(v.value);
    case TAG_GEOMETRY_POLYGON:
      return new GeometryPolygon(v.value);
    case TAG_GEOMETRY_MULTIPOINT:
      return new GeometryMultiPoint(v.value);
    case TAG_GEOMETRY_MULTILINE:
      return new GeometryMultiLine(v.value);
    case TAG_GEOMETRY_MULTIPOLYGON:
      return new GeometryMultiPolygon(v.value);
    case TAG_GEOMETRY_COLLECTION:
      return new GeometryCollection(v.value);
  }
} };
Object.freeze(replacer);
function encodeCbor(data) {
  return encode(data, { replacer: replacer.encode });
}
function decodeCbor(data) {
  return decode(data, { replacer: replacer.decode });
}
var textEncoder2;
var PreparedQuery = class {
  constructor(query, bindings) {
    __publicField(this, "_query");
    __publicField(this, "_bindings");
    __publicField(this, "length");
    textEncoder2 ?? (textEncoder2 = new TextEncoder()), this._query = textEncoder2.encode(query), this._bindings = partiallyEncodeObject(bindings ?? {}, { replacer: replacer.encode }), this.length = Object.keys(this._bindings).length;
  }
  get query() {
    let w = new Writer(this._query.byteLength + 9);
    return w.writeMajor(3, this._query.byteLength), w.writeUint8Array(this._query), new Encoded(w.output(false));
  }
  get bindings() {
    return this._bindings;
  }
  build(fills) {
    return encode([this.query, this.bindings], { fills });
  }
  append(query_raw, ...values) {
    let base = this.length;
    this.length += values.length;
    let reused = 0, gaps = /* @__PURE__ */ new Map(), mapped_bindings = values.map((v, i) => {
      if (v instanceof Gap) {
        let index = gaps.get(v);
        if (index !== void 0) return reused++, [`bind___${index}`, v];
        gaps.set(v, i - reused);
      }
      return [`bind___${base + i - reused}`, v];
    });
    for (let [k, v] of mapped_bindings) this._bindings[k] = encode(v, { replacer: replacer.encode, partial: true });
    let query = query_raw.flatMap((segment, i) => {
      var _a;
      let variable = (_a = mapped_bindings[i]) == null ? void 0 : _a[0];
      return [segment, ...variable ? [`$${variable}`] : []];
    }).join("");
    textEncoder2 ?? (textEncoder2 = new TextEncoder());
    let current = new Uint8Array(this._query), added = textEncoder2.encode(query);
    return this._query = new Uint8Array(current.byteLength + added.byteLength), this._query.set(current), this._query.set(added, current.byteLength), this;
  }
};
function surrealql(query_raw, ...values) {
  let reused = 0, gaps = /* @__PURE__ */ new Map(), mapped_bindings = values.map((v, i) => {
    if (v instanceof Gap) {
      let index = gaps.get(v);
      if (index !== void 0) return reused++, [`bind___${index}`, v];
      gaps.set(v, i - reused);
    }
    return [`bind___${i - reused}`, v];
  }), bindings = mapped_bindings.reduce((prev, [k, v]) => (prev[k] = v, prev), {}), query = query_raw.flatMap((segment, i) => {
    var _a;
    let variable = (_a = mapped_bindings[i]) == null ? void 0 : _a[0];
    return [segment, ...variable ? [`$${variable}`] : []];
  }).join("");
  return new PreparedQuery(query, bindings);
}
function convertAuth(params) {
  let result = {}, convertString = (a, b, optional) => {
    if (a in params) result[b] = `${params[a]}`, delete result[a];
    else if (optional !== true) throw new SurrealDbError(`Key ${a} is missing from the authentication parameters`);
  };
  return "scope" in params ? (result = { ...params }, convertString("scope", "sc"), convertString("namespace", "ns"), convertString("database", "db")) : "variables" in params ? (result = { ...params.variables }, convertString("access", "ac"), convertString("namespace", "ns"), convertString("database", "db")) : (convertString("access", "ac", true), convertString("database", "db", true), convertString("namespace", "ns", !("database" in params)), convertString("username", "user"), convertString("password", "pass")), result;
}
var liveActions = ["CREATE", "UPDATE", "DELETE"];
function isLiveResult(v) {
  return !(typeof v != "object" || v === null || !("id" in v && "action" in v && "result" in v) || !(v.id instanceof Uuid) || !liveActions.includes(v.action) || typeof v.result != "object" || v.result === null);
}
var DEFAULT_RECONNECT_OPTIONS = { enabled: true, attempts: 5, retryDelay: 1e3, retryDelayMax: 6e4, retryDelayMultiplier: 2, retryDelayJitter: 0.1 };
function jsonify(input) {
  if (typeof input == "object") {
    if (input === null) return null;
    if (input instanceof Date || input instanceof Uuid || input instanceof Decimal || input instanceof Duration || input instanceof Future || input instanceof Range || input instanceof StringRecordId || input instanceof RecordIdRange || input instanceof RecordId || input instanceof Geometry || input instanceof Table) return input.toJSON();
    switch (Object.getPrototypeOf(input)) {
      case Object.prototype: {
        let mapped = Object.entries(input).map(([k, v]) => [k, jsonify(v)]).filter(([_, v]) => v !== void 0);
        return Object.fromEntries(mapped);
      }
      case Map.prototype: {
        let mapped = Array.from(input).map(([k, v]) => [k, jsonify(v)]).filter(([_, v]) => v !== void 0);
        return new Map(mapped);
      }
      case Array.prototype:
        return input.map(jsonify);
      case Set.prototype:
        return new Set([...input].map(jsonify));
    }
  }
  return input;
}
var defaultVersionCheckTimeout = 5e3;
var supportedSurrealDbVersionMin = "1.4.2";
var supportedSurrealDbVersionUntil = "3.0.0";
var supportedSurrealDbVersionRange = `>= ${supportedSurrealDbVersionMin} < ${supportedSurrealDbVersionUntil}`;
function versionCheck(version, min = supportedSurrealDbVersionMin, until = supportedSurrealDbVersionUntil) {
  if (!isVersionSupported(version, min, until)) throw new UnsupportedVersion(version, `>= ${min} < ${until}`);
  return true;
}
function isVersionSupported(version, min = supportedSurrealDbVersionMin, until = supportedSurrealDbVersionUntil) {
  return min.localeCompare(version, void 0, { numeric: true }) <= 0 && until.localeCompare(version, void 0, { numeric: true }) === 1;
}
async function retrieveRemoteVersion(url, timeout) {
  let protocol = { "ws:": "http:", "wss:": "https:", "http:": "http:", "https:": "https:" }[url.protocol];
  if (protocol) {
    let basepath = url.pathname.slice(0, -4);
    url = new URL(url), url.pathname = `${basepath}/version`, url.protocol = protocol;
    let controller = new AbortController(), id2 = setTimeout(() => controller.abort(), timeout ?? defaultVersionCheckTimeout), versionPrefix = "surrealdb-";
    return await fetch(url, { signal: controller.signal }).then((res) => res.text()).then((version2) => version2.slice(versionPrefix.length)).catch((e) => {
      throw new VersionRetrievalFailure(e);
    }).finally(() => {
      clearTimeout(id2);
    });
  }
  throw new VersionRetrievalFailure();
}
var id = 0;
function getIncrementalID() {
  return id = (id + 1) % Number.MAX_SAFE_INTEGER, id.toString();
}
function s(string, ...values) {
  return string.reduce((prev, curr, i) => `${prev}${curr}${values[i] ?? ""}`, "");
}
function d(string, ...values) {
  return new Date(s(string, values));
}
function r(string, ...values) {
  return new StringRecordId(s(string, values));
}
function u(string, ...values) {
  return new Uuid(s(string, values));
}
var RetryMessage = Symbol("RetryMessage");
var ConnectionStatus = ((ConnectionStatus2) => (ConnectionStatus2.Disconnected = "disconnected", ConnectionStatus2.Connecting = "connecting", ConnectionStatus2.Reconnecting = "reconnecting", ConnectionStatus2.Connected = "connected", ConnectionStatus2.Error = "error", ConnectionStatus2))(ConnectionStatus || {});
var EngineContext = class {
  constructor({ emitter, encodeCbor: encodeCbor2, decodeCbor: decodeCbor2, reconnect, prepare }) {
    __publicField(this, "emitter");
    __publicField(this, "encodeCbor");
    __publicField(this, "decodeCbor");
    __publicField(this, "reconnect");
    __publicField(this, "prepare");
    this.emitter = emitter, this.encodeCbor = encodeCbor2, this.decodeCbor = decodeCbor2, this.reconnect = reconnect, this.prepare = prepare;
  }
};
var AbstractEngine = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "ready");
    __publicField(this, "status", "disconnected");
    __publicField(this, "connection", { url: void 0, namespace: void 0, database: void 0, token: void 0 });
    this.context = context;
  }
  get emitter() {
    return this.context.emitter;
  }
  get encodeCbor() {
    return this.context.encodeCbor;
  }
  get decodeCbor() {
    return this.context.decodeCbor;
  }
};
function processAuthVars(vars, fallback) {
  if ("scope" in vars || "access" in vars && "variables" in vars && vars.variables) {
    if (!vars.namespace) {
      if (!(fallback == null ? void 0 : fallback.namespace)) throw new NoNamespaceSpecified();
      vars.namespace = fallback.namespace;
    }
    if (!vars.database) {
      if (!(fallback == null ? void 0 : fallback.database)) throw new NoDatabaseSpecified();
      vars.database = fallback.database;
    }
  }
  return vars;
}
var AuthController = class {
  async signup(vars) {
    if (!this.connection) throw new NoActiveSocket();
    let parsed = processAuthVars(vars, this.connection.connection), converted = convertAuth(parsed), res = await this.rpc("signup", [converted]);
    if (res.error) throw new ResponseError(res.error.message);
    if (!res.result) throw new NoTokenReturned();
    return res.result;
  }
  async signin(vars) {
    if (!this.connection) throw new NoActiveSocket();
    let parsed = processAuthVars(vars, this.connection.connection), converted = convertAuth(parsed), res = await this.rpc("signin", [converted]);
    if (res.error) throw new ResponseError(res.error.message);
    if (!res.result) throw new NoTokenReturned();
    return res.result;
  }
  async authenticate(token) {
    let res = await this.rpc("authenticate", [token]);
    if (res.error) throw new ResponseError(res.error.message);
    return true;
  }
  async invalidate() {
    let res = await this.rpc("invalidate");
    if (res.error) throw new ResponseError(res.error.message);
    return true;
  }
};
var EngineAuth = class extends AuthController {
  constructor(connection) {
    super();
    this.connection = connection;
  }
  rpc(method, params) {
    if (!this.connection) throw new NoActiveSocket();
    return this.connection.rpc({ method, params });
  }
};
var AbstractRemoteEngine = class extends AbstractEngine {
  async req_post(body, url, headers_) {
    let headers = { "Content-Type": "application/cbor", Accept: "application/cbor", ...headers_ };
    this.connection.namespace && (headers["Surreal-NS"] = this.connection.namespace), this.connection.database && (headers["Surreal-DB"] = this.connection.database), this.connection.token && (headers.Authorization = `Bearer ${this.connection.token}`);
    let raw = await fetch(`${url ?? this.connection.url}`, { method: "POST", headers, body: this.encodeCbor(body) }), buffer = await raw.arrayBuffer();
    if (raw.status === 200) return buffer;
    let dec = new TextDecoder("utf-8");
    throw new HttpConnectionError(dec.decode(buffer), raw.status, raw.statusText, buffer);
  }
};
var ALWAYS_ALLOW = /* @__PURE__ */ new Set(["signin", "signup", "authenticate", "invalidate", "version", "use", "let", "unset", "query"]);
var HttpEngine = class extends AbstractRemoteEngine {
  constructor() {
    super(...arguments);
    __publicField(this, "connection", { url: void 0, namespace: void 0, database: void 0, token: void 0, variables: {} });
  }
  setStatus(status, ...args) {
    this.status = status, this.emitter.emit(status, args);
  }
  version(url, timeout) {
    return retrieveRemoteVersion(url, timeout);
  }
  async connect(url) {
    var _a, _b;
    return this.setStatus("connecting"), this.connection.url = url, await ((_b = (_a = this.context).prepare) == null ? void 0 : _b.call(_a, new EngineAuth(this))), this.setStatus("connected"), this.ready = new Promise((r2) => r2()), this.ready;
  }
  disconnect() {
    return this.connection = { url: void 0, namespace: void 0, database: void 0, token: void 0, variables: {} }, this.ready = void 0, this.setStatus("disconnected"), new Promise((r2) => r2());
  }
  async rpc(request) {
    var _a, _b;
    if (await this.ready, !this.connection.url) throw new ConnectionUnavailable();
    if ((!this.connection.namespace || !this.connection.database) && !ALWAYS_ALLOW.has(request.method)) throw new MissingNamespaceDatabase();
    if (request.method === "use") {
      let [ns, db] = request.params;
      return ns === null && (this.connection.namespace = void 0), db === null && (this.connection.database = void 0), ns && (this.connection.namespace = ns), db && (this.connection.database = db), { result: true };
    }
    if (request.method === "let") {
      let [key, value] = request.params;
      return this.connection.variables[key] = value, { result: true };
    }
    if (request.method === "unset") {
      let [key] = request.params;
      return delete this.connection.variables[key], { result: true };
    }
    request.method === "query" && (request.params = [(_a = request.params) == null ? void 0 : _a[0], { ...this.connection.variables, ...((_b = request.params) == null ? void 0 : _b[1]) ?? {} }]);
    let id2 = getIncrementalID(), buffer = await this.req_post({ id: id2, ...request }), response = this.decodeCbor(buffer);
    if ("result" in response) switch (request.method) {
      case "signin":
      case "signup": {
        this.connection.token = response.result;
        break;
      }
      case "authenticate": {
        let [token] = request.params;
        this.connection.token = token;
        break;
      }
      case "invalidate": {
        this.connection.token = void 0;
        break;
      }
    }
    return this.emitter.emit(`rpc-${id2}`, [response]), response;
  }
  get connected() {
    return !!this.connection.url;
  }
  async export(options) {
    if (!this.connection.url) throw new ConnectionUnavailable();
    let url = new URL(this.connection.url), basepath = url.pathname.slice(0, -4);
    url.pathname = `${basepath}/export`;
    let buffer = await this.req_post(options ?? {}, url, { Accept: "plain/text" });
    return new TextDecoder("utf-8").decode(buffer);
  }
  async import(data) {
    if (!this.connection.url) throw new ConnectionUnavailable();
    let url = new URL(this.connection.url), basepath = url.pathname.slice(0, -4);
    url.pathname = `${basepath}/import`, await this.req_post(data, url, { Accept: "application/json" });
  }
};
function newCompletable() {
  let out = { completed: false };
  return out.promise = new Promise((resolve_, reject_) => {
    out.resolve = (arg) => {
      out.completed = true, resolve_(arg);
    }, out.reject = (reason) => {
      out.completed = true, reject_(reason);
    };
  }), out;
}
var WebsocketEngine = class extends AbstractRemoteEngine {
  constructor(ctx) {
    super(ctx);
    __publicField(this, "pinger");
    __publicField(this, "socket");
    __publicField(this, "disconnected");
    this.disconnected = newCompletable();
  }
  setStatus(status, ...args) {
    this.connection.url && status === "disconnected" || status === "error" ? (this.disconnected.resolve(), this.disconnected = newCompletable()) : (this.status = status, this.emitter.emit(status, args));
  }
  async requireStatus(status) {
    return this.status !== status && await this.emitter.subscribeOnce(status), true;
  }
  version(url, timeout) {
    return retrieveRemoteVersion(url, timeout);
  }
  async connect(url) {
    this.connection.url = url, (async () => {
      let initial = true, controls;
      for (; this.connection.url; ) if (initial) initial = false, this.setStatus("connecting"), this.ready = this.createSocket(), await this.disconnected.promise;
      else {
        if (!this.context.reconnect.enabled) break;
        if (!controls) {
          let { promise, resolve: resolve2, reject: reject2 } = newCompletable();
          this.ready = promise, controls = [resolve2, reject2];
        }
        let [resolve, reject] = controls;
        if (!this.context.reconnect.allowed) {
          this.connection = { url: void 0, namespace: void 0, database: void 0, token: void 0 }, this.socket = void 0, reject(new ReconnectFailed()), this.emitter.emit("error", [new ReconnectFailed()]), this.setStatus("disconnected");
          break;
        }
        this.setStatus("reconnecting"), await this.context.reconnect.iterate();
        try {
          await this.createSocket();
        } catch {
          continue;
        }
        try {
          if (this.connection.namespace || this.connection.database) {
            let res = await this.rpc({ method: "use", params: [this.connection.namespace, this.connection.database] }, true);
            if (res.error) throw new ResponseError(res.error.message);
          }
          if (this.connection.token) {
            let res = await this.rpc({ method: "authenticate", params: [this.connection.token] }, true);
            if (res.error) throw new ResponseError(res.error.message);
          }
        } catch (e) {
          this.connection = { url: void 0, namespace: void 0, database: void 0, token: void 0 }, this.socket = void 0, reject(e), this.emitter.emit("error", [e]), this.setStatus("disconnected");
          break;
        }
        this.context.reconnect.reset(), resolve(), this.emitter.scanListeners((k) => k.startsWith("rpc-")).map((k) => this.emitter.emit(k, [RetryMessage])), this.status === "connected" && await this.disconnected.promise;
      }
    })(), await this.ready;
  }
  async createSocket() {
    let { promise, resolve, reject } = newCompletable();
    if (!this.connection.url) throw new NoURLProvided();
    let socket = new WebSocket2(this.connection.url.toString(), "cbor");
    socket.addEventListener("open", async () => {
      var _a, _b;
      await ((_b = (_a = this.context).prepare) == null ? void 0 : _b.call(_a, new EngineAuth(this))), this.setStatus("connected"), resolve();
    }), socket.addEventListener("error", (e) => {
      let error = new UnexpectedConnectionError("detail" in e && e.detail ? e.detail : "message" in e && e.message ? e.message : "error" in e && e.error ? e.error : "An unexpected error occurred");
      this.setStatus("error", error), reject(error);
    }), socket.addEventListener("close", () => {
      var _a;
      this.setStatus("disconnected"), (_a = this.pinger) == null ? void 0 : _a.stop();
    }), socket.addEventListener("message", async ({ data }) => {
      try {
        let decoded = this.decodeCbor(data instanceof ArrayBuffer ? data : data instanceof Blob ? await data.arrayBuffer() : data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
        if (typeof decoded == "object" && decoded != null && Object.getPrototypeOf(decoded) === Object.prototype) this.handleRpcResponse(decoded);
        else throw new UnexpectedServerResponse(decoded);
      } catch (detail) {
        socket.dispatchEvent(new CustomEvent("error", { detail }));
      }
    }), await promise.then(() => {
      var _a;
      this.socket = socket, (_a = this.pinger) == null ? void 0 : _a.stop(), this.pinger = new Pinger(3e4), this.pinger.start(() => {
        try {
          this.rpc({ method: "ping" });
        } catch {
        }
      });
    });
  }
  async disconnect() {
    var _a, _b;
    this.connection = { url: void 0, namespace: void 0, database: void 0, token: void 0 }, await ((_a = this.ready) == null ? void 0 : _a.catch(() => {
    })), (_b = this.socket) == null ? void 0 : _b.close(), this.ready = void 0, this.socket = void 0, this.disconnected.resolve(), await Promise.any([this.requireStatus("disconnected"), this.requireStatus("error")]);
  }
  async rpc(request, force) {
    if (force || await this.ready, !this.socket) throw new ConnectionUnavailable();
    let res;
    for (; !res; ) {
      let id2 = getIncrementalID(), response = this.emitter.subscribeOnce(`rpc-${id2}`);
      if (this.socket.send(this.encodeCbor({ id: id2, ...request })), force && this.socket.readyState === WebSocket2.CLOSED) throw new EngineDisconnected();
      let [raw] = await response;
      if (raw instanceof EngineDisconnected) throw raw;
      raw !== RetryMessage && (res = raw);
    }
    if ("result" in res) switch (request.method) {
      case "use": {
        let [ns, db] = request.params;
        ns === null && (this.connection.namespace = void 0), db === null && (this.connection.database = void 0), ns && (this.connection.namespace = ns), db && (this.connection.database = db);
        break;
      }
      case "signin":
      case "signup": {
        this.connection.token = res.result;
        break;
      }
      case "authenticate": {
        let [token] = request.params;
        this.connection.token = token;
        break;
      }
      case "invalidate": {
        this.connection.token = void 0;
        break;
      }
    }
    return res;
  }
  handleRpcResponse({ id: id2, ...res }) {
    if (id2) this.emitter.emit(`rpc-${id2}`, [res]);
    else if (res.error) this.setStatus("error", new ResponseError(res.error));
    else if (isLiveResult(res.result)) {
      let { id: id3, action, result } = res.result;
      this.emitter.emit(`live-${id3}`, [action, result], true);
    } else this.setStatus("error", new UnexpectedServerResponse({ id: id2, ...res }));
  }
  get connected() {
    return !!this.socket;
  }
  async export(options) {
    if (!this.connection.url) throw new ConnectionUnavailable();
    let url = new URL(this.connection.url), basepath = url.pathname.slice(0, -4);
    url.protocol = url.protocol.replace("ws", "http"), url.pathname = `${basepath}/export`;
    let buffer = await this.req_post(options ?? {}, url, { Accept: "plain/text" });
    return new TextDecoder("utf-8").decode(buffer);
  }
  async import(data) {
    if (!this.connection.url) throw new ConnectionUnavailable();
    let url = new URL(this.connection.url), basepath = url.pathname.slice(0, -4);
    url.protocol = url.protocol.replace("ws", "http"), url.pathname = `${basepath}/import`, await this.req_post(data, url, { Accept: "application/json" });
  }
};
var Pinger = class {
  constructor(interval = 3e4) {
    __publicField(this, "pinger");
    __publicField(this, "interval");
    this.interval = interval;
  }
  start(callback) {
    this.pinger = setInterval(callback, this.interval);
  }
  stop() {
    clearInterval(this.pinger);
  }
};
function rand(min, max) {
  return Math.random() * (max - min) + min;
}
var ReconnectContext = class {
  constructor(input, surreal) {
    __publicField(this, "_attempts", 0);
    __publicField(this, "options");
    __publicField(this, "surreal");
    this.surreal = surreal, input ? input === true ? this.options = DEFAULT_RECONNECT_OPTIONS : this.options = { ...DEFAULT_RECONNECT_OPTIONS, ...input } : this.options = { ...DEFAULT_RECONNECT_OPTIONS, enabled: false };
  }
  get attempts() {
    return this._attempts;
  }
  get enabled() {
    return this.options.enabled;
  }
  get allowed() {
    return !(!this.options.enabled || this.options.attempts !== -1 && this._attempts >= this.options.attempts);
  }
  reset() {
    this._attempts = 0;
  }
  async iterate() {
    if (!this.allowed) throw new ReconnectIterationError();
    this._attempts++;
    let multiplier = this.options.retryDelayMultiplier ** this.attempts, adjustedDelay = this.options.retryDelay * multiplier, jitterModifier = rand(-this.options.retryDelayJitter, this.options.retryDelayJitter), nextDelay = Math.min(adjustedDelay * (1 + jitterModifier), this.options.retryDelayMax);
    await new Promise((r2) => setTimeout(r2, nextDelay));
  }
};
var Surreal = class extends AuthController {
  constructor({ engines } = {}) {
    super();
    __publicField(this, "connection");
    __publicField(this, "emitter");
    __publicField(this, "engines", { ws: WebsocketEngine, wss: WebsocketEngine, http: HttpEngine, https: HttpEngine });
    __publicField(this, "_ready");
    this.emitter = new Emitter(), engines && (this.engines = { ...this.engines, ...engines });
  }
  async connect(url, opts = {}) {
    return this._ready = this.connectInner(url, opts), await this._ready, true;
  }
  async connectInner(url, opts = {}) {
    let endpoint = parseUrl(url), engineName = endpoint.protocol.slice(0, -1), engine = this.engines[engineName];
    if (!engine) throw new UnsupportedEngine(engineName);
    let { prepare, auth, namespace, database, reconnect } = opts;
    await this.close();
    let context = new EngineContext({ emitter: this.emitter, encodeCbor, decodeCbor, reconnect: new ReconnectContext(reconnect, this), prepare }), connection = new engine(context);
    if (opts.versionCheck !== false) {
      let version = await connection.version(endpoint, opts.versionCheckTimeout);
      versionCheck(version);
    }
    this.connection = connection, await connection.connect(endpoint), (namespace || database) && await this.use({ namespace, database }), typeof auth == "string" ? await this.authenticate(auth) : auth && await this.signin(auth);
  }
  async close() {
    var _a;
    return this.clean(), await ((_a = this.connection) == null ? void 0 : _a.disconnect()), true;
  }
  clean() {
    let pending = this.emitter.scanListeners((k) => k.startsWith("rpc-"));
    pending.map((k) => this.emitter.emit(k, [new EngineDisconnected()]));
    let live = this.emitter.scanListeners((k) => k.startsWith("live-"));
    live.map((k) => this.emitter.emit(k, ["CLOSE", "disconnected"])), this.emitter.reset({ collectable: true, listeners: [...pending, ...live] });
  }
  get status() {
    var _a;
    return ((_a = this.connection) == null ? void 0 : _a.status) ?? "disconnected";
  }
  get ready() {
    var _a;
    return Promise.all([this._ready, (_a = this.connection) == null ? void 0 : _a.ready]).then(() => {
    });
  }
  async ping() {
    let { error } = await this.rpc("ping");
    if (error) throw new ResponseError(error.message);
    return true;
  }
  async use({ namespace, database }) {
    if (!this.connection) throw new NoActiveSocket();
    if (namespace === null && database !== null) throw new SurrealDbError("Cannot unset namespace without unsetting database");
    let { error } = await this.rpc("use", [namespace, database]);
    if (error) throw new ResponseError(error.message);
    return true;
  }
  async info() {
    await this.ready;
    let res = await this.rpc("info");
    if (res.error) throw new ResponseError(res.error.message);
    return res.result ?? void 0;
  }
  async let(variable, value) {
    let res = await this.rpc("let", [variable, value]);
    if (res.error) throw new ResponseError(res.error.message);
    return true;
  }
  async unset(variable) {
    let res = await this.rpc("unset", [variable]);
    if (res.error) throw new ResponseError(res.error.message);
    return true;
  }
  async live(table, callback, diff) {
    await this.ready;
    let res = await this.rpc("live", [table, diff]);
    if (res.error) throw new ResponseError(res.error.message);
    return callback && this.subscribeLive(res.result, callback), res.result;
  }
  async subscribeLive(queryUuid, callback) {
    if (await this.ready, !this.connection) throw new NoActiveSocket();
    this.connection.emitter.subscribe(`live-${queryUuid}`, callback, true);
  }
  async unSubscribeLive(queryUuid, callback) {
    if (await this.ready, !this.connection) throw new NoActiveSocket();
    this.connection.emitter.unSubscribe(`live-${queryUuid}`, callback);
  }
  async kill(queryUuid) {
    if (await this.ready, !this.connection) throw new NoActiveSocket();
    if (Array.isArray(queryUuid)) {
      await Promise.all(queryUuid.map((u2) => this.rpc("kill", [u2])));
      let toBeKilled = queryUuid.map((u2) => `live-${u2}`);
      toBeKilled.map((k) => this.emitter.emit(k, ["CLOSE", "killed"])), this.connection.emitter.reset({ collectable: toBeKilled, listeners: toBeKilled });
    } else await this.rpc("kill", [queryUuid]), this.emitter.emit(`live-${queryUuid}`, ["CLOSE", "killed"]), this.connection.emitter.reset({ collectable: `live-${queryUuid}`, listeners: `live-${queryUuid}` });
  }
  async query(...args) {
    return (await this.queryRaw(...args)).map(({ status, result }) => {
      if (status === "ERR") throw new ResponseError(result);
      return result;
    });
  }
  async queryRaw(...[q, b]) {
    let params = q instanceof PreparedQuery ? [q.query, partiallyEncodeObject(q.bindings, { fills: b, replacer: replacer.encode })] : [q, b];
    await this.ready;
    let res = await this.rpc("query", params);
    if (res.error) throw new ResponseError(res.error.message);
    return res.result;
  }
  async query_raw(...args) {
    return this.queryRaw(...args);
  }
  async select(thing) {
    await this.ready;
    let res = await this.rpc("select", [thing]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async create(thing, data) {
    await this.ready;
    let res = await this.rpc("create", [thing, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async insert(arg1, arg2) {
    await this.ready;
    let [table, data] = typeof arg1 == "string" || arg1 instanceof Table ? [arg1, arg2] : [void 0, arg1], res = await this.rpc("insert", [table, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return res.result;
  }
  async insertRelation(arg1, arg2) {
    await this.ready;
    let [table, data] = typeof arg1 == "string" || arg1 instanceof Table ? [arg1, arg2] : [void 0, arg1], res = await this.rpc("insert_relation", [table, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return res.result;
  }
  async insert_relation(arg1, arg2) {
    return arg1 instanceof Table || typeof arg1 == "string" ? this.insertRelation(arg1, arg2) : this.insertRelation(arg1);
  }
  async update(thing, data) {
    await this.ready;
    let res = await this.rpc("update", [thing, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async upsert(thing, data) {
    await this.ready;
    let res = await this.rpc("upsert", [thing, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async merge(thing, data) {
    await this.ready;
    let res = await this.rpc("merge", [thing, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async patch(thing, data, diff) {
    await this.ready;
    let res = await this.rpc("patch", [thing, data, diff]);
    if (res.error) throw new ResponseError(res.error.message);
    return diff ? res.result : output(thing, res.result);
  }
  async delete(thing) {
    await this.ready;
    let res = await this.rpc("delete", [thing]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  async version() {
    await this.ready;
    let res = await this.rpc("version");
    if (res.error) throw new ResponseError(res.error.message);
    return res.result;
  }
  async run(name, arg2, arg3) {
    await this.ready;
    let [version, args] = Array.isArray(arg2) ? [void 0, arg2] : [arg2, arg3], res = await this.rpc("run", [name, version, args]);
    if (res.error) throw new ResponseError(res.error.message);
    return res.result;
  }
  async relate(from, thing, to, data) {
    await this.ready;
    let res = await this.rpc("relate", [from, thing, to, data]);
    if (res.error) throw new ResponseError(res.error.message);
    return output(thing, res.result);
  }
  rpc(method, params) {
    if (!this.connection) throw new NoActiveSocket();
    return this.connection.rpc({ method, params });
  }
  async export(options) {
    if (await this.ready, !this.connection) throw new NoActiveSocket();
    return this.connection.export(options);
  }
  async import(input) {
    if (await this.ready, !this.connection) throw new NoActiveSocket();
    return this.connection.import(input);
  }
};
function output(subject, input) {
  return subject instanceof RecordId || subject instanceof StringRecordId ? Array.isArray(input) ? input[0] : input : Array.isArray(input) ? input : [input];
}
function parseUrl(value) {
  let url = new URL(value);
  return url.pathname.endsWith("/rpc") || (url.pathname.endsWith("/") || (url.pathname += "/"), url.pathname += "rpc"), url;
}
export {
  AbstractEngine,
  AuthController,
  BoundExcluded,
  BoundIncluded,
  CborBreak,
  CborError,
  CborFillMissing,
  CborInvalidMajorError,
  CborNumberError,
  CborPartialDisabled,
  CborRangeError,
  ConnectionStatus,
  ConnectionUnavailable,
  DEFAULT_RECONNECT_OPTIONS,
  Decimal,
  Duration,
  Emitter,
  EngineAuth,
  EngineDisconnected,
  FeatureUnavailableForEngine,
  Future,
  Gap,
  Geometry,
  GeometryCollection,
  GeometryLine,
  GeometryMultiLine,
  GeometryMultiPoint,
  GeometryMultiPolygon,
  GeometryPoint,
  GeometryPolygon,
  HttpConnectionError,
  InvalidURLProvided,
  MissingNamespaceDatabase,
  NoActiveSocket,
  NoConnectionDetails,
  NoDatabaseSpecified,
  NoNamespaceSpecified,
  NoTokenReturned,
  NoURLProvided,
  PreparedQuery,
  Range,
  ReconnectFailed,
  ReconnectIterationError,
  RecordId,
  RecordIdRange,
  ResponseError,
  StringRecordId,
  Surreal,
  SurrealDbError,
  Table,
  UnexpectedConnectionError,
  UnexpectedResponse,
  UnexpectedServerResponse,
  UnsupportedEngine,
  UnsupportedVersion,
  Uuid,
  VersionRetrievalFailure,
  cbor_exports as cbor,
  convertAuth,
  d,
  decodeCbor,
  Surreal as default,
  defaultVersionCheckTimeout,
  encodeCbor,
  equals,
  escapeIdent,
  escapeNumber,
  escape_ident,
  getIncrementalID,
  isLiveResult,
  isVersionSupported,
  jsonify,
  liveActions,
  r,
  retrieveRemoteVersion,
  s,
  supportedSurrealDbVersionMin,
  supportedSurrealDbVersionRange,
  supportedSurrealDbVersionUntil,
  surrealql as surql,
  surrealql,
  toSurrealqlString,
  u,
  versionCheck
};
/*! Bundled license information:

uuidv7/dist/index.js:
  (**
   * uuidv7: A JavaScript implementation of UUID version 7
   *
   * Copyright 2021-2024 LiosK
   *
   * @license Apache-2.0
   * @packageDocumentation
   *)
*/
//# sourceMappingURL=surrealdb.js.map
