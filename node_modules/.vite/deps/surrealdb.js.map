{
  "version": 3,
  "sources": ["../../.pnpm/uuidv7@1.0.2/node_modules/uuidv7/dist/index.js", "../../.pnpm/isows@1.0.6_ws@8.18.1/node_modules/isows/utils.ts", "../../.pnpm/isows@1.0.6_ws@8.18.1/node_modules/isows/native.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/emitter.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/gap.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/index.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/constants.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/encoded.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/errors.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/error.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/writer.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/partial.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/tagged.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/encoder.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/reader.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/util.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/cbor/decoder.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/datetime.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/value.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/decimal.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/duration.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/future.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/geometry.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/equals.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/escape.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/uuid.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/recordid.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/table.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/to-surrealql-string.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/types/range.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/data/cbor.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/prepared-query.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/tagged-template.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/types.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/jsonify.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/version-check.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/get-incremental-id.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/string-prefixes.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/engines/abstract.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/process-auth-vars.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/auth.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/engines/abstract-remote.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/engines/http.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/engines/ws.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/completable.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/rand.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/util/reconnect.ts", "../../.pnpm/surrealdb@1.3.1_tslib@2.8.1_typescript@5.8.2_ws@8.18.1/node_modules/surrealdb/src/surreal.ts"],
  "sourcesContent": ["/**\n * uuidv7: A JavaScript implementation of UUID version 7\n *\n * Copyright 2021-2024 LiosK\n *\n * @license Apache-2.0\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nexport class UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 9562 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */\nexport class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nexport const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nexport const uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n", "export function getNativeWebSocket() {\n  if (typeof WebSocket !== \"undefined\") return WebSocket;\n  if (typeof global.WebSocket !== \"undefined\") return global.WebSocket;\n  if (typeof window.WebSocket !== \"undefined\") return window.WebSocket;\n  if (typeof self.WebSocket !== \"undefined\") return self.WebSocket;\n  throw new Error(\"`WebSocket` is not supported in this environment\");\n}\n", "import { getNativeWebSocket } from \"./utils.js\";\n\nexport const WebSocket = getNativeWebSocket();\n\ntype MessageEvent_ = MessageEvent;\nexport type { MessageEvent_ as MessageEvent };\n", "export type Listener<Args extends unknown[] = unknown[]> = (\n\t...args: Args\n) => unknown;\nexport type UnknownEvents = Record<string, unknown[]>;\n\n/**\n * A class used to subscribe to and emit events\n */\nexport class Emitter<Events extends UnknownEvents = UnknownEvents> {\n\tprivate collectable: Partial<{\n\t\t[K in keyof Events]: Events[K][];\n\t}> = {};\n\n\tprivate listeners: Partial<{\n\t\t[K in keyof Events]: Listener<Events[K]>[];\n\t}> = {};\n\n\tprivate readonly interceptors: Partial<{\n\t\t[K in keyof Events]: (...args: Events[K]) => Promise<Events[K]>;\n\t}>;\n\n\tconstructor({\n\t\tinterceptors,\n\t}: {\n\t\tinterceptors?: Partial<{\n\t\t\t[K in keyof Events]: (...args: Events[K]) => Promise<Events[K]>;\n\t\t}>;\n\t} = {}) {\n\t\tthis.interceptors = interceptors ?? {};\n\t}\n\n\tsubscribe<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t\thistoric = false,\n\t): void {\n\t\tif (!this.listeners[event]) {\n\t\t\tthis.listeners[event] = [];\n\t\t}\n\n\t\tif (!this.isSubscribed(event, listener)) {\n\t\t\tthis.listeners[event]?.push(listener);\n\n\t\t\tif (historic && this.collectable[event]) {\n\t\t\t\tconst buffer = this.collectable[event];\n\t\t\t\tdelete this.collectable[event];\n\t\t\t\tfor (const args of buffer) {\n\t\t\t\t\tlistener(...args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync subscribeOnce<Event extends keyof Events>(\n\t\tevent: Event,\n\t\thistoric = false,\n\t): Promise<Events[Event]> {\n\t\tif (historic && this.collectable[event]) {\n\t\t\tconst args = this.collectable[event]?.shift();\n\t\t\tif (this.collectable[event]?.length === 0) {\n\t\t\t\tdelete this.collectable[event];\n\t\t\t}\n\n\t\t\tif (args) return args;\n\t\t}\n\n\t\treturn new Promise<Events[Event]>((resolve) => {\n\t\t\tlet resolved = false;\n\t\t\tconst listener = (...args: Events[Event]) => {\n\t\t\t\tif (!resolved) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tthis.unSubscribe(event, listener);\n\t\t\t\t\tresolve(args);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.subscribe(event, listener, false);\n\t\t});\n\t}\n\n\tunSubscribe<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t): void {\n\t\tif (this.listeners[event]) {\n\t\t\tconst index = this.listeners[event]?.findIndex((v) => v === listener);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.listeners[event]?.splice(index, 1);\n\t\t\t\tif (this.listeners[event]?.length === 0) {\n\t\t\t\t\tdelete this.listeners[event];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisSubscribed<Event extends keyof Events>(\n\t\tevent: Event,\n\t\tlistener: Listener<Events[Event]>,\n\t): boolean {\n\t\treturn !!this.listeners[event]?.includes(listener);\n\t}\n\n\tasync emit<Event extends keyof Events>(\n\t\tevent: Event,\n\t\targs: Events[Event],\n\t\tcollectable = false,\n\t): Promise<void> {\n\t\tconst interceptor = this.interceptors[event];\n\t\tconst computedArgs = interceptor ? await interceptor(...args) : args;\n\n\t\tif (\n\t\t\t(collectable && !this.listeners[event]) ||\n\t\t\tthis.listeners[event]?.length === 0\n\t\t) {\n\t\t\tif (!this.collectable[event]) {\n\t\t\t\tthis.collectable[event] = [];\n\t\t\t}\n\n\t\t\tthis.collectable[event]?.push(args);\n\t\t}\n\n\t\tfor (const listener of this.listeners[event] ?? []) {\n\t\t\tlistener(...computedArgs);\n\t\t}\n\t}\n\n\treset({\n\t\tcollectable,\n\t\tlisteners,\n\t}: {\n\t\tcollectable?: boolean | keyof Events | (keyof Events)[];\n\t\tlisteners?: boolean | keyof Events | (keyof Events)[];\n\t}): void {\n\t\tif (Array.isArray(collectable)) {\n\t\t\tfor (const k of collectable) {\n\t\t\t\tdelete this.collectable[k];\n\t\t\t}\n\t\t} else if (typeof collectable === \"string\") {\n\t\t\tdelete this.collectable[collectable];\n\t\t} else if (collectable !== false) {\n\t\t\tthis.collectable = {};\n\t\t}\n\n\t\tif (Array.isArray(listeners)) {\n\t\t\tfor (const k of listeners) {\n\t\t\t\tdelete this.listeners[k];\n\t\t\t}\n\t\t} else if (typeof listeners === \"string\") {\n\t\t\tdelete this.listeners[listeners];\n\t\t} else if (listeners !== false) {\n\t\t\tthis.listeners = {};\n\t\t}\n\t}\n\n\tscanListeners(filter?: (k: keyof Events) => boolean): (keyof Events)[] {\n\t\tlet listeners = Object.keys(this.listeners) as (keyof Events)[];\n\t\tif (filter) listeners = listeners.filter(filter);\n\t\treturn listeners;\n\t}\n}\n", "// Why is the default value being stored in an array? undefined, null, false, etc... are all valid defaults,\n// and specifying a field on a class as optional will make it undefined by default.\n\nexport type Fill<T = unknown> = [Gap<T>, T];\nexport class Gap<T = unknown> {\n\treadonly args: [T?] = [];\n\tconstructor(...args: [T?]) {\n\t\tthis.args = args;\n\t}\n\n\tfill(value: T): Fill<T> {\n\t\treturn [this, value];\n\t}\n\n\thasDefault(): boolean {\n\t\treturn this.args.length === 1;\n\t}\n\n\tget default(): T | undefined {\n\t\treturn this.args[0];\n\t}\n}\n", "export * from \"./constants\";\nexport * from \"./encoder\";\nexport * from \"./decoder\";\nexport * from \"./util\";\nexport * from \"./reader\";\nexport * from \"./writer\";\nexport * from \"./tagged\";\nexport * from \"./error\";\nexport * from \"./gap\";\nexport * from \"./partial\";\nexport * from \"./encoded\";\n", "export type Replacer = (v: unknown) => unknown;\nexport type Major = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;\nexport const POW_2_53: number = 2 ** 53;\nexport const POW_2_64: bigint = BigInt(2 ** 64);\n", "export class Encoded {\n\tconstructor(readonly encoded: ArrayBuffer) {}\n}\n", "export class SurrealDbError extends Error {}\n\nexport class NoActiveSocket extends SurrealDbError {\n\tname = \"NoActiveSocket\";\n\tmessage =\n\t\t\"No socket is currently connected to a SurrealDB instance. Please call the .connect() method first!\";\n}\n\nexport class NoConnectionDetails extends SurrealDbError {\n\tname = \"NoConnectionDetails\";\n\tmessage =\n\t\t\"No connection details for the HTTP api have been provided. Please call the .connect() method first!\";\n}\n\nexport class UnexpectedResponse extends SurrealDbError {\n\tname = \"UnexpectedResponse\";\n\tmessage =\n\t\t\"The returned response from the SurrealDB instance is in an unexpected format. Unable to process response!\";\n}\n\nexport class InvalidURLProvided extends SurrealDbError {\n\tname = \"InvalidURLProvided\";\n\tmessage =\n\t\t\"The provided string is either not a URL or is a URL but with an invalid protocol!\";\n}\n\nexport class NoURLProvided extends SurrealDbError {\n\tname = \"NoURLProvided\";\n\tmessage =\n\t\t\"Tried to establish a connection while no connection URL was provided\";\n}\n\nexport class EngineDisconnected extends SurrealDbError {\n\tname = \"EngineDisconnected\";\n\tmessage = \"The engine reported the connection to SurrealDB has dropped\";\n}\n\nexport class ReconnectFailed extends SurrealDbError {\n\tname = \"ReconnectFailed\";\n\tmessage = \"The engine failed to reconnect to SurrealDB\";\n}\n\nexport class ReconnectIterationError extends SurrealDbError {\n\tname = \"ReconnectIterationError\";\n\tmessage = \"The reconnect iterator failed to iterate\";\n}\n\nexport class UnexpectedServerResponse extends SurrealDbError {\n\tname = \"UnexpectedServerResponse\";\n\n\tconstructor(public readonly response: unknown) {\n\t\tsuper();\n\t\tthis.message = `${response}`;\n\t}\n}\n\nexport class UnexpectedConnectionError extends SurrealDbError {\n\tname = \"UnexpectedConnectionError\";\n\n\tconstructor(public readonly error: unknown) {\n\t\tsuper();\n\t\tthis.message = `${error}`;\n\t}\n}\n\nexport class UnsupportedEngine extends SurrealDbError {\n\tname = \"UnsupportedEngine\";\n\tmessage =\n\t\t\"The engine you are trying to connect to is not supported or configured.\";\n\n\tconstructor(public readonly engine: string) {\n\t\tsuper();\n\t}\n}\n\nexport class FeatureUnavailableForEngine extends SurrealDbError {\n\tname = \"FeatureUnavailableForEngine\";\n\tmessage =\n\t\t\"The feature you are trying to use is not available on this engine.\";\n}\n\nexport class ConnectionUnavailable extends SurrealDbError {\n\tname = \"ConnectionUnavailable\";\n\tmessage = \"There is no connection available at this moment.\";\n}\n\nexport class MissingNamespaceDatabase extends SurrealDbError {\n\tname = \"MissingNamespaceDatabase\";\n\tmessage = \"There is no namespace and/or database selected.\";\n}\n\nexport class HttpConnectionError extends SurrealDbError {\n\tname = \"HttpConnectionError\";\n\n\tconstructor(\n\t\tpublic readonly message: string,\n\t\tpublic readonly status: number,\n\t\tpublic readonly statusText: string,\n\t\tpublic readonly buffer: ArrayBuffer,\n\t) {\n\t\tsuper();\n\t}\n}\n\nexport class ResponseError extends SurrealDbError {\n\tname = \"ResponseError\";\n\n\tconstructor(public readonly message: string) {\n\t\tsuper();\n\t}\n}\n\nexport class NoNamespaceSpecified extends SurrealDbError {\n\tname = \"NoNamespaceSpecified\";\n\tmessage = \"Please specify a namespace to use.\";\n}\n\nexport class NoDatabaseSpecified extends SurrealDbError {\n\tname = \"NoDatabaseSpecified\";\n\tmessage = \"Please specify a database to use.\";\n}\n\nexport class NoTokenReturned extends SurrealDbError {\n\tname = \"NoTokenReturned\";\n\tmessage = \"Did not receive an authentication token.\";\n}\n\nexport class UnsupportedVersion extends SurrealDbError {\n\tname = \"UnsupportedVersion\";\n\tversion: string;\n\tsupportedRange: string;\n\n\tconstructor(version: string, supportedRange: string) {\n\t\tsuper();\n\t\tthis.version = version;\n\t\tthis.supportedRange = supportedRange;\n\t\tthis.message = `The version \"${version}\" reported by the engine is not supported by this library, expected a version that satisfies \"${supportedRange}\".`;\n\t}\n}\n\nexport class VersionRetrievalFailure extends SurrealDbError {\n\tname = \"VersionRetrievalFailure\";\n\tmessage =\n\t\t\"Failed to retrieve remote version. If the server is behind a proxy, make sure it's configured correctly.\";\n\n\tconstructor(readonly error?: Error | undefined) {\n\t\tsuper();\n\t}\n}\n", "import { SurrealDbError } from \"../errors\";\n\nexport abstract class CborError extends SurrealDbError {\n\tabstract readonly name: string;\n\treadonly message: string;\n\n\tconstructor(message: string) {\n\t\tsuper();\n\t\tthis.message = message;\n\t}\n}\n\nexport class CborNumberError extends CborError {\n\tname = \"CborNumberError\";\n}\n\nexport class CborRangeError extends CborError {\n\tname = \"CborRangeError\";\n}\n\nexport class CborInvalidMajorError extends CborError {\n\tname = \"CborInvalidMajorError\";\n}\n\nexport class CborBreak extends CborError {\n\tname = \"CborBreak\";\n\tconstructor() {\n\t\tsuper(\"Came across a break which was not intercepted by the decoder\");\n\t}\n}\n\nexport class CborPartialDisabled extends CborError {\n\tname = \"CborPartialDisabled\";\n\tconstructor() {\n\t\tsuper(\n\t\t\t\"Tried to insert a Gap into a CBOR value, while partial mode is not enabled\",\n\t\t);\n\t}\n}\n\nexport class CborFillMissing extends CborError {\n\tname = \"CborFillMissing\";\n\tconstructor() {\n\t\tsuper(\"Fill for a gap is missing, and gap has no default\");\n\t}\n}\n", "import type { Major, Replacer } from \"./constants\";\nimport type { Gap } from \"./gap\";\nimport { PartiallyEncoded } from \"./partial\";\n\nexport class Writer {\n\tprivate _chunks: [ArrayBuffer, Gap][] = [];\n\tprivate _pos = 0;\n\tprivate _buf: ArrayBuffer;\n\tprivate _view: DataView;\n\tprivate _byte: Uint8Array;\n\n\tconstructor(readonly byteLength = 256) {\n\t\tthis._buf = new ArrayBuffer(this.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t}\n\n\tchunk(gap: Gap): void {\n\t\tthis._chunks.push([this._buf.slice(0, this._pos), gap]);\n\t\tthis._buf = new ArrayBuffer(this.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t\tthis._pos = 0;\n\t}\n\n\tget chunks(): [ArrayBuffer, Gap][] {\n\t\treturn this._chunks;\n\t}\n\n\tget buffer(): ArrayBuffer {\n\t\treturn this._buf.slice(0, this._pos);\n\t}\n\n\tprivate claim(length: number) {\n\t\tconst pos = this._pos;\n\t\tthis._pos += length;\n\t\tif (this._pos <= this._buf.byteLength) return pos;\n\n\t\tlet newLen = this._buf.byteLength << 1;\n\t\twhile (newLen < this._pos) newLen <<= 1;\n\t\tif (newLen > this._buf.byteLength) {\n\t\t\tconst oldb = this._byte;\n\t\t\tthis._buf = new ArrayBuffer(newLen);\n\t\t\tthis._view = new DataView(this._buf);\n\t\t\tthis._byte = new Uint8Array(this._buf);\n\t\t\tthis._byte.set(oldb);\n\t\t}\n\t\treturn pos;\n\t}\n\n\twriteUint8(value: number): void {\n\t\tconst pos = this.claim(1);\n\t\tthis._view.setUint8(pos, value);\n\t}\n\n\twriteUint16(value: number): void {\n\t\tconst pos = this.claim(2);\n\t\tthis._view.setUint16(pos, value);\n\t}\n\n\twriteUint32(value: number): void {\n\t\tconst pos = this.claim(4);\n\t\tthis._view.setUint32(pos, value);\n\t}\n\n\twriteUint64(value: bigint): void {\n\t\tconst pos = this.claim(8);\n\t\tthis._view.setBigUint64(pos, value);\n\t}\n\n\twriteUint8Array(data: Uint8Array): void {\n\t\tif (data.byteLength === 0) return;\n\t\tconst pos = this.claim(data.byteLength);\n\t\tthis._byte.set(data, pos);\n\t}\n\n\twriteArrayBuffer(data: ArrayBuffer): void {\n\t\tif (data.byteLength === 0) return;\n\t\tthis.writeUint8Array(new Uint8Array(data));\n\t}\n\n\twritePartiallyEncoded(data: PartiallyEncoded): void {\n\t\tfor (const [buf, gap] of data.chunks) {\n\t\t\tthis.writeArrayBuffer(buf);\n\t\t\tthis.chunk(gap);\n\t\t}\n\n\t\tthis.writeArrayBuffer(data.end);\n\t}\n\n\twriteFloat32(value: number): void {\n\t\tconst pos = this.claim(4);\n\t\tthis._view.setFloat32(pos, value);\n\t}\n\n\twriteFloat64(value: number): void {\n\t\tconst pos = this.claim(8);\n\t\tthis._view.setFloat64(pos, value);\n\t}\n\n\twriteMajor(type: Major, length: number | bigint): void {\n\t\tconst base = type << 5;\n\t\tif (length < 24) {\n\t\t\tthis.writeUint8(base + Number(length));\n\t\t} else if (length < 0x100) {\n\t\t\tthis.writeUint8(base + 24);\n\t\t\tthis.writeUint8(Number(length));\n\t\t} else if (length < 0x10000) {\n\t\t\tthis.writeUint8(base + 25);\n\t\t\tthis.writeUint16(Number(length));\n\t\t} else if (length < 0x100000000) {\n\t\t\tthis.writeUint8(base + 26);\n\t\t\tthis.writeUint32(Number(length));\n\t\t} else {\n\t\t\tthis.writeUint8(base + 27);\n\t\t\tthis.writeUint64(BigInt(length));\n\t\t}\n\t}\n\n\toutput<Partial extends boolean = false>(\n\t\tpartial: Partial,\n\t\treplacer?: Replacer,\n\t): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\t\tif (partial) {\n\t\t\treturn new PartiallyEncoded(\n\t\t\t\tthis._chunks,\n\t\t\t\tthis.buffer,\n\t\t\t\treplacer,\n\t\t\t) as Partial extends true ? PartiallyEncoded : ArrayBuffer;\n\t\t}\n\n\t\treturn this.buffer as Partial extends true ? PartiallyEncoded : ArrayBuffer;\n\t}\n}\n", "import type { Replacer } from \"./constants\";\nimport { type EncoderOptions, encode } from \"./encoder\";\nimport { CborFillMissing } from \"./error\";\nimport type { Fill, Gap } from \"./gap\";\nimport { Writer } from \"./writer\";\n\nexport class PartiallyEncoded {\n\tconstructor(\n\t\treadonly chunks: [ArrayBuffer, Gap][],\n\t\treadonly end: ArrayBuffer,\n\t\treadonly replacer: Replacer | undefined,\n\t) {}\n\n\tbuild<Partial extends boolean = false>(\n\t\tfills: Fill[],\n\t\tpartial?: Partial,\n\t): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\t\tconst writer = new Writer();\n\t\tconst map = new Map(fills);\n\n\t\tfor (const [buffer, gap] of this.chunks) {\n\t\t\tconst hasValue = map.has(gap) || gap.hasDefault();\n\t\t\tif (!partial && !hasValue) throw new CborFillMissing();\n\t\t\twriter.writeArrayBuffer(buffer);\n\n\t\t\tif (hasValue) {\n\t\t\t\tconst data = map.get(gap) ?? gap.default;\n\t\t\t\tencode(data, {\n\t\t\t\t\twriter,\n\t\t\t\t\treplacer: this.replacer,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\twriter.chunk(gap);\n\t\t\t}\n\t\t}\n\n\t\twriter.writeArrayBuffer(this.end);\n\t\treturn writer.output<Partial>(!!partial as Partial, this.replacer);\n\t}\n}\n\nexport function partiallyEncodeObject(\n\tobject: Record<string, unknown>,\n\toptions?: EncoderOptions<true>,\n): Record<string, PartiallyEncoded> {\n\treturn Object.fromEntries(\n\t\tObject.entries(object).map(([k, v]) => [\n\t\t\tk,\n\t\t\tencode(v, { ...options, partial: true }),\n\t\t]),\n\t);\n}\n", "export class Tagged<T = unknown> {\n\tconstructor(\n\t\treadonly tag: number | bigint,\n\t\treadonly value: T,\n\t) {}\n}\n", "import { POW_2_53, POW_2_64, type Replacer } from \"./constants\";\nimport { Encoded } from \"./encoded\";\nimport { CborNumberError, CborPartialDisabled } from \"./error\";\nimport { type Fill, Gap } from \"./gap\";\nimport { PartiallyEncoded } from \"./partial\";\nimport { Tagged } from \"./tagged\";\nimport { Writer } from \"./writer\";\n\nlet textEncoder: TextEncoder;\n\nexport interface EncoderOptions<Partial extends boolean> {\n\treplacer?: Replacer;\n\twriter?: Writer;\n\tpartial?: Partial;\n\tfills?: Fill[];\n}\n\nexport function encode<Partial extends boolean = false>(\n\tinput: unknown,\n\toptions: EncoderOptions<Partial> = {},\n): Partial extends true ? PartiallyEncoded : ArrayBuffer {\n\tconst w = options.writer ?? new Writer();\n\tconst fillsMap = new Map(options.fills ?? []);\n\n\tfunction inner(input: unknown) {\n\t\tconst value = options.replacer ? options.replacer(input) : input;\n\n\t\tif (value === undefined) return w.writeUint8(0xf7);\n\t\tif (value === null) return w.writeUint8(0xf6);\n\t\tif (value === true) return w.writeUint8(0xf5);\n\t\tif (value === false) return w.writeUint8(0xf4);\n\n\t\tswitch (typeof value) {\n\t\t\tcase \"number\": {\n\t\t\t\tif (Number.isInteger(value)) {\n\t\t\t\t\tif (value >= 0 && value <= POW_2_53) {\n\t\t\t\t\t\tw.writeMajor(0, value);\n\t\t\t\t\t} else if (value < 0 && value >= -POW_2_53) {\n\t\t\t\t\t\tw.writeMajor(1, -(value + 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new CborNumberError(\"Number too big to be encoded\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Better precision when encoded as 64-bit\n\t\t\t\t\tw.writeUint8(0xfb);\n\t\t\t\t\tw.writeFloat64(value);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"bigint\": {\n\t\t\t\tif (value >= 0 && value < POW_2_64) {\n\t\t\t\t\tw.writeMajor(0, value);\n\t\t\t\t} else if (value <= 0 && value >= -POW_2_64) {\n\t\t\t\t\tw.writeMajor(1, -(value + 1n));\n\t\t\t\t} else {\n\t\t\t\t\tthrow new CborNumberError(\"BigInt too big to be encoded\");\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"string\": {\n\t\t\t\ttextEncoder ??= new TextEncoder();\n\t\t\t\tconst encoded = textEncoder.encode(value);\n\t\t\t\tw.writeMajor(3, encoded.byteLength);\n\t\t\t\tw.writeUint8Array(encoded);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tw.writeMajor(4, value.length);\n\t\t\t\t\tfor (const v of value) {\n\t\t\t\t\t\tinner(v);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Tagged) {\n\t\t\t\t\tw.writeMajor(6, value.tag);\n\t\t\t\t\tinner(value.value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Encoded) {\n\t\t\t\t\tw.writeArrayBuffer(value.encoded);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Gap) {\n\t\t\t\t\tif (fillsMap.has(value)) {\n\t\t\t\t\t\tinner(fillsMap.get(value));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!options.partial) throw new CborPartialDisabled();\n\t\t\t\t\t\tw.chunk(value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof PartiallyEncoded) {\n\t\t\t\t\tconst res = value.build<Partial>(\n\t\t\t\t\t\toptions.fills ?? [],\n\t\t\t\t\t\toptions.partial,\n\t\t\t\t\t);\n\t\t\t\t\tif (options.partial) {\n\t\t\t\t\t\tw.writePartiallyEncoded(res as PartiallyEncoded);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw.writeArrayBuffer(res as ArrayBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tvalue instanceof Uint8Array ||\n\t\t\t\t\tvalue instanceof Uint16Array ||\n\t\t\t\t\tvalue instanceof Uint32Array ||\n\t\t\t\t\tvalue instanceof Int8Array ||\n\t\t\t\t\tvalue instanceof Int16Array ||\n\t\t\t\t\tvalue instanceof Int32Array ||\n\t\t\t\t\tvalue instanceof Float32Array ||\n\t\t\t\t\tvalue instanceof Float64Array ||\n\t\t\t\t\tvalue instanceof ArrayBuffer\n\t\t\t\t) {\n\t\t\t\t\tconst v = new Uint8Array(value);\n\t\t\t\t\tw.writeMajor(2, v.byteLength);\n\t\t\t\t\tw.writeUint8Array(v);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst entries =\n\t\t\t\t\tvalue instanceof Map\n\t\t\t\t\t\t? Array.from(value.entries())\n\t\t\t\t\t\t: Object.entries(value);\n\n\t\t\t\tw.writeMajor(5, entries.length);\n\t\t\t\tfor (const v of entries.flat()) {\n\t\t\t\t\tinner(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinner(input);\n\treturn w.output<Partial>(!!options.partial as Partial, options.replacer);\n}\n", "import { type Major, POW_2_53 } from \"./constants\";\nimport { CborInvalidMajorError, CborRangeError } from \"./error\";\n\nexport class Reader {\n\tprivate _buf: ArrayBufferLike;\n\tprivate _view: DataView;\n\tprivate _byte: Uint8Array;\n\tprivate _pos = 0;\n\n\tconstructor(buffer: ArrayBufferLike) {\n\t\tthis._buf = new ArrayBuffer(buffer.byteLength);\n\t\tthis._view = new DataView(this._buf);\n\t\tthis._byte = new Uint8Array(this._buf);\n\t\tthis._byte.set(new Uint8Array(buffer));\n\t}\n\n\tprivate read<T>(amount: number, res: T): T {\n\t\tthis._pos += amount;\n\t\treturn res;\n\t}\n\n\treadUint8(): number {\n\t\ttry {\n\t\t\treturn this.read(1, this._view.getUint8(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint16(): number {\n\t\ttry {\n\t\t\treturn this.read(2, this._view.getUint16(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint32(): number {\n\t\ttry {\n\t\t\treturn this.read(4, this._view.getUint32(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadUint64(): bigint {\n\t\ttry {\n\t\t\treturn this.read(8, this._view.getBigUint64(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// https://stackoverflow.com/a/5684578\n\treadFloat16(): number {\n\t\tconst bytes = this.readUint16();\n\t\tconst s = (bytes & 0x8000) >> 15;\n\t\tconst e = (bytes & 0x7c00) >> 10;\n\t\tconst f = bytes & 0x03ff;\n\n\t\tif (e === 0) {\n\t\t\treturn (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n\t\t}\n\n\t\tif (e === 0x1f) {\n\t\t\treturn f ? Number.NaN : (s ? -1 : 1) * Number.POSITIVE_INFINITY;\n\t\t}\n\n\t\treturn (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n\t}\n\n\treadFloat32(): number {\n\t\ttry {\n\t\t\treturn this.read(4, this._view.getFloat32(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadFloat64(): number {\n\t\ttry {\n\t\t\treturn this.read(8, this._view.getFloat64(this._pos));\n\t\t} catch (e) {\n\t\t\tif (e instanceof RangeError) throw new CborRangeError(e.message);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\treadBytes(amount: number): Uint8Array {\n\t\tconst available = this._byte.length - this._pos;\n\t\tif (available < amount)\n\t\t\tthrow new CborRangeError(\n\t\t\t\t`The argument must be between 0 and ${available}`,\n\t\t\t);\n\n\t\treturn this.read(amount, this._byte.slice(this._pos, this._pos + amount));\n\t}\n\n\treadMajor(): [Major, number] {\n\t\tconst byte = this.readUint8();\n\t\tconst major = (byte >> 5) as Major;\n\t\tif (major < 0 || major > 7)\n\t\t\tthrow new CborInvalidMajorError(\"Received invalid major type\");\n\t\treturn [major, byte & 0x1f];\n\t}\n\n\treadMajorLength(length: number): number | bigint {\n\t\tif (length <= 23) return length;\n\n\t\tswitch (length) {\n\t\t\tcase 24:\n\t\t\t\treturn this.readUint8();\n\t\t\tcase 25:\n\t\t\t\treturn this.readUint16();\n\t\t\tcase 26:\n\t\t\t\treturn this.readUint32();\n\t\t\tcase 27: {\n\t\t\t\tconst read = this.readUint64();\n\t\t\t\treturn read > POW_2_53 ? read : Number(read);\n\t\t\t}\n\t\t}\n\n\t\tthrow new CborRangeError(\"Expected a final length\");\n\t}\n}\n", "import type { Major } from \"./constants\";\nimport { CborInvalidMajorError, CborRangeError } from \"./error\";\nimport type { Reader } from \"./reader\";\nimport { Writer } from \"./writer\";\n\nexport function infiniteBytes(r: Reader, forMajor: Major): ArrayBuffer {\n\tconst w = new Writer();\n\twhile (true) {\n\t\tconst [major, len] = r.readMajor();\n\n\t\t// Received break signal\n\t\tif (major === 7 && len === 31) break;\n\n\t\t// Resource type has to match\n\t\tif (major !== forMajor)\n\t\t\tthrow new CborInvalidMajorError(\n\t\t\t\t`Expected a resource of the same major (${forMajor}) while processing an infinite resource`,\n\t\t\t);\n\n\t\t// Cannot have an infinite resource in an infinite resource\n\t\tif (len === 31)\n\t\t\tthrow new CborRangeError(\n\t\t\t\t\"Expected a finite resource while processing an infinite resource\",\n\t\t\t);\n\n\t\tw.writeUint8Array(r.readBytes(Number(r.readMajorLength(len))));\n\t}\n\n\treturn w.buffer;\n}\n", "import type { Replacer } from \"./constants\";\nimport { CborBreak, CborInvalidMajorError } from \"./error\";\nimport { Reader } from \"./reader\";\nimport { Tagged } from \"./tagged\";\nimport { infiniteBytes } from \"./util\";\n\nlet textDecoder: TextDecoder;\n\nexport interface DecodeOptions {\n\tmap?: \"object\" | \"map\";\n\treplacer?: Replacer;\n}\n\nexport function decode(\n\tinput: ArrayBufferLike | Reader,\n\toptions: DecodeOptions = {},\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n): any {\n\tconst r = input instanceof Reader ? input : new Reader(input);\n\n\tfunction inner() {\n\t\tconst [major, len] = r.readMajor();\n\t\tswitch (major) {\n\t\t\tcase 0:\n\t\t\t\treturn r.readMajorLength(len);\n\t\t\tcase 1: {\n\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\treturn typeof l === \"bigint\" ? -(l + 1n) : -(l + 1);\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tif (len === 31) return infiniteBytes(r, 2);\n\t\t\t\treturn r.readBytes(Number(r.readMajorLength(len))).buffer;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tconst encoded =\n\t\t\t\t\tlen === 31\n\t\t\t\t\t\t? infiniteBytes(r, 3)\n\t\t\t\t\t\t: r.readBytes(Number(r.readMajorLength(len)));\n\n\t\t\t\ttextDecoder ??= new TextDecoder();\n\t\t\t\treturn textDecoder.decode(encoded);\n\t\t\t}\n\n\t\t\tcase 4: {\n\t\t\t\tif (len === 31) {\n\t\t\t\t\tconst arr = [];\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tarr.push(decode());\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e instanceof CborBreak) break;\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\n\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\tconst arr = Array(l);\n\t\t\t\tfor (let i = 0; i < l; i++) arr[i] = decode();\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\tcase 5: {\n\t\t\t\tconst entries: [string, unknown][] = [];\n\t\t\t\tif (len === 31) {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tlet key: string;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tkey = decode();\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tif (e instanceof CborBreak) break;\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst value = decode();\n\t\t\t\t\t\tentries.push([key, value]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst l = r.readMajorLength(len);\n\t\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\t\tconst key = decode();\n\t\t\t\t\t\tconst value = decode();\n\t\t\t\t\t\tentries[i] = [key, value];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn options.map === \"map\"\n\t\t\t\t\t? new Map(entries)\n\t\t\t\t\t: Object.fromEntries(entries);\n\t\t\t}\n\n\t\t\tcase 6: {\n\t\t\t\tconst tag = r.readMajorLength(len);\n\t\t\t\tconst value = decode();\n\t\t\t\treturn new Tagged(tag, value);\n\t\t\t}\n\n\t\t\tcase 7: {\n\t\t\t\tswitch (len) {\n\t\t\t\t\tcase 20:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase 21:\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 22:\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tcase 23:\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\tcase 25:\n\t\t\t\t\t\treturn r.readFloat16();\n\t\t\t\t\tcase 26:\n\t\t\t\t\t\treturn r.readFloat32();\n\t\t\t\t\tcase 27:\n\t\t\t\t\t\treturn r.readFloat64();\n\t\t\t\t\tcase 31:\n\t\t\t\t\t\tthrow new CborBreak();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthrow new CborInvalidMajorError(\n\t\t\t`Unable to decode value with major tag ${major}`,\n\t\t);\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\tfunction decode(): any {\n\t\treturn options.replacer ? options.replacer(inner()) : inner();\n\t}\n\n\treturn decode();\n}\n", "export function msToNs(ms: number): number {\n\treturn ms * 1000000;\n}\n\nexport function nsToMs(ns: number): number {\n\treturn Math.floor(ns / 1000000);\n}\n\nexport function dateToCborCustomDate(date: Date): [number, number] {\n\tconst s = Math.floor(date.getTime() / 1000);\n\tconst ms = date.getTime() - s * 1000;\n\treturn [s, ms * 1000000];\n}\n\nexport function cborCustomDateToDate([s, ns]: [number, number]): Date {\n\tconst date = new Date(0);\n\tdate.setUTCSeconds(Number(s));\n\tdate.setMilliseconds(Math.floor(Number(ns) / 1000000));\n\treturn date;\n}\n", "/**\n * A complex SurrealQL value type\n */\nexport abstract class Value {\n\t/**\n\t * Compare equality with another value.\n\t */\n\tabstract equals(other: unknown): boolean;\n\n\t/**\n\t * Convert this value to a serializable string\n\t */\n\tabstract toJSON(): unknown;\n\n\t/**\n\t * Convert this value to a string representation\n\t */\n\tabstract toString(): string;\n}\n", "import { Value } from \"../value\";\n\n/**\n * A SurrealQL decimal value.\n */\nexport class Decimal extends Value {\n\treadonly decimal: string;\n\n\tconstructor(decimal: string | number | Decimal) {\n\t\tsuper();\n\t\tthis.decimal = decimal.toString();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Decimal)) return false;\n\t\treturn this.decimal === other.decimal;\n\t}\n\n\ttoString(): string {\n\t\treturn this.decimal;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.decimal;\n\t}\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { Value } from \"../value\";\n\nconst millisecond = 1;\nconst microsecond = millisecond / 1000;\nconst nanosecond = microsecond / 1000;\nconst second = 1000 * millisecond;\nconst minute = 60 * second;\nconst hour = 60 * minute;\nconst day = 24 * hour;\nconst week = 7 * day;\n\nconst units = new Map([\n\t[\"ns\", nanosecond],\n\t[\"\u00B5s\", microsecond],\n\t[\"\u03BCs\", microsecond], // They look similar, but this unit is a different charachter than the one above it.\n\t[\"us\", microsecond], // needs to come last to be the displayed unit\n\t[\"ms\", millisecond],\n\t[\"s\", second],\n\t[\"m\", minute],\n\t[\"h\", hour],\n\t[\"d\", day],\n\t[\"w\", week],\n]);\n\nconst unitsReverse = Array.from(units).reduce((map, [unit, size]) => {\n\tmap.set(size, unit);\n\treturn map;\n}, new Map<number, string>());\n\nconst durationPartRegex = new RegExp(\n\t`^(\\\\d+)(${Array.from(units.keys()).join(\"|\")})`,\n);\n\n/**\n * A SurrealQL duration value.\n */\nexport class Duration extends Value {\n\treadonly _milliseconds: number;\n\n\tconstructor(input: Duration | number | string) {\n\t\tsuper();\n\n\t\tif (input instanceof Duration) {\n\t\t\tthis._milliseconds = input._milliseconds;\n\t\t} else if (typeof input === \"string\") {\n\t\t\tthis._milliseconds = Duration.parseString(input);\n\t\t} else {\n\t\t\tthis._milliseconds = input;\n\t\t}\n\t}\n\n\tstatic fromCompact([s, ns]: [number, number] | [number] | []): Duration {\n\t\ts = s ?? 0;\n\t\tns = ns ?? 0;\n\t\tconst ms = s * 1000 + ns / 1000000;\n\t\treturn new Duration(ms);\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Duration)) return false;\n\t\treturn this._milliseconds === other._milliseconds;\n\t}\n\n\ttoCompact(): [number, number] | [number] | [] {\n\t\tconst s = Math.floor(this._milliseconds / 1000);\n\t\tconst ns = Math.floor((this._milliseconds - s * 1000) * 1000000);\n\t\treturn ns > 0 ? [s, ns] : s > 0 ? [s] : [];\n\t}\n\n\ttoString(): string {\n\t\tlet left = this._milliseconds;\n\t\tlet result = \"\";\n\t\tfunction scrap(size: number) {\n\t\t\tconst num = Math.floor(left / size);\n\t\t\tif (num > 0) left = left % size;\n\t\t\treturn num;\n\t\t}\n\n\t\tfor (const [size, unit] of Array.from(unitsReverse).reverse()) {\n\t\t\tconst scrapped = scrap(size);\n\t\t\tif (scrapped > 0) result += `${scrapped}${unit}`;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\tstatic parseString(input: string): number {\n\t\tlet ms = 0;\n\t\tlet left = input;\n\t\twhile (left !== \"\") {\n\t\t\tconst match = left.match(durationPartRegex);\n\t\t\tif (match) {\n\t\t\t\tconst amount = Number.parseInt(match[1]);\n\t\t\t\tconst factor = units.get(match[2]);\n\t\t\t\tif (factor === undefined)\n\t\t\t\t\tthrow new SurrealDbError(`Invalid duration unit: ${match[2]}`);\n\n\t\t\t\tms += amount * factor;\n\t\t\t\tleft = left.slice(match[0].length);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthrow new SurrealDbError(\"Could not match a next duration part\");\n\t\t}\n\n\t\treturn ms;\n\t}\n\n\tstatic nanoseconds(nanoseconds: number): Duration {\n\t\treturn new Duration(Math.floor(nanoseconds * nanosecond));\n\t}\n\n\tstatic microseconds(microseconds: number): Duration {\n\t\treturn new Duration(Math.floor(microseconds * microsecond));\n\t}\n\n\tstatic milliseconds(milliseconds: number): Duration {\n\t\treturn new Duration(milliseconds);\n\t}\n\n\tstatic seconds(seconds: number): Duration {\n\t\treturn new Duration(seconds * second);\n\t}\n\n\tstatic minutes(minutes: number): Duration {\n\t\treturn new Duration(minutes * minute);\n\t}\n\n\tstatic hours(hours: number): Duration {\n\t\treturn new Duration(hours * hour);\n\t}\n\n\tstatic days(days: number): Duration {\n\t\treturn new Duration(days * day);\n\t}\n\n\tstatic weeks(weeks: number): Duration {\n\t\treturn new Duration(weeks * week);\n\t}\n\n\tget microseconds(): number {\n\t\treturn Math.floor(this._milliseconds / microsecond);\n\t}\n\n\tget nanoseconds(): number {\n\t\treturn Math.floor(this._milliseconds / nanosecond);\n\t}\n\n\tget milliseconds(): number {\n\t\treturn Math.floor(this._milliseconds);\n\t}\n\n\tget seconds(): number {\n\t\treturn Math.floor(this._milliseconds / second);\n\t}\n\n\tget minutes(): number {\n\t\treturn Math.floor(this._milliseconds / minute);\n\t}\n\n\tget hours(): number {\n\t\treturn Math.floor(this._milliseconds / hour);\n\t}\n\n\tget days(): number {\n\t\treturn Math.floor(this._milliseconds / day);\n\t}\n\n\tget weeks(): number {\n\t\treturn Math.floor(this._milliseconds / week);\n\t}\n}\n", "import { Value } from \"../value\";\n\n/**\n * An uncomputed SurrealQL future value.\n */\nexport class Future extends Value {\n\tconstructor(readonly inner: string) {\n\t\tsuper();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Future)) return false;\n\t\treturn this.inner === other.inner;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\treturn `<future> ${this.inner}`;\n\t}\n}\n", "import { Value } from \"../value.ts\";\nimport { Decimal } from \"./decimal.ts\";\n\n/**\n * A SurrealQL geometry value.\n */\nexport abstract class Geometry extends Value {\n\tabstract toJSON(): GeoJson;\n\tabstract is(geometry: Geometry): boolean;\n\tabstract clone(): Geometry;\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Geometry)) return false;\n\t\treturn this.is(other);\n\t}\n\n\ttoString(): string {\n\t\treturn JSON.stringify(this.toJSON());\n\t}\n}\n\nfunction f(num: number | Decimal) {\n\tif (num instanceof Decimal) return Number.parseFloat(num.decimal);\n\treturn num;\n}\n\n/**\n * A SurrealQL point geometry value.\n */\nexport class GeometryPoint extends Geometry {\n\treadonly point: [number, number];\n\n\tconstructor(point: [number | Decimal, number | Decimal] | GeometryPoint) {\n\t\tsuper();\n\t\tif (point instanceof GeometryPoint) {\n\t\t\tthis.point = point.clone().point;\n\t\t} else {\n\t\t\tthis.point = [f(point[0]), f(point[1])];\n\t\t}\n\t}\n\n\ttoJSON(): GeoJsonPoint {\n\t\treturn {\n\t\t\ttype: \"Point\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonPoint[\"coordinates\"] {\n\t\treturn this.point;\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryPoint {\n\t\tif (!(geometry instanceof GeometryPoint)) return false;\n\t\treturn (\n\t\t\tthis.point[0] === geometry.point[0] && this.point[1] === geometry.point[1]\n\t\t);\n\t}\n\n\tclone(): GeometryPoint {\n\t\treturn new GeometryPoint([...this.point]);\n\t}\n}\n\n/**\n * A SurrealQL line geometry value.\n */\nexport class GeometryLine extends Geometry {\n\treadonly line: [GeometryPoint, GeometryPoint, ...GeometryPoint[]];\n\n\t// SurrealDB only has the concept of a \"Line\", which by spec is two points.\n\t// SurrealDB's \"Line\" however, is actually a \"LineString\" under the hood, which accepts two or more points\n\tconstructor(\n\t\tline: [GeometryPoint, GeometryPoint, ...GeometryPoint[]] | GeometryLine,\n\t) {\n\t\tsuper();\n\t\tthis.line = line instanceof GeometryLine ? line.clone().line : line;\n\t}\n\n\ttoJSON(): GeoJsonLineString {\n\t\treturn {\n\t\t\ttype: \"LineString\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonLineString[\"coordinates\"] {\n\t\treturn this.line.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonLineString[\"coordinates\"];\n\t}\n\n\tclose(): void {\n\t\tif (!this.line[0].is(this.line.at(-1) as GeometryPoint)) {\n\t\t\tthis.line.push(this.line[0]);\n\t\t}\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryLine {\n\t\tif (!(geometry instanceof GeometryLine)) return false;\n\t\tif (this.line.length !== geometry.line.length) return false;\n\t\tfor (let i = 0; i < this.line.length; i++) {\n\t\t\tif (!this.line[i].is(geometry.line[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryLine {\n\t\treturn new GeometryLine(\n\t\t\tthis.line.map((p) => p.clone()) as [\n\t\t\t\tGeometryPoint,\n\t\t\t\tGeometryPoint,\n\t\t\t\t...GeometryPoint[],\n\t\t\t],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL polygon geometry value.\n */\nexport class GeometryPolygon extends Geometry {\n\treadonly polygon: [GeometryLine, ...GeometryLine[]];\n\n\tconstructor(polygon: [GeometryLine, ...GeometryLine[]] | GeometryPolygon) {\n\t\tsuper();\n\t\tthis.polygon =\n\t\t\tpolygon instanceof GeometryPolygon\n\t\t\t\t? polygon.clone().polygon\n\t\t\t\t: (polygon.map((l) => {\n\t\t\t\t\t\tconst line = l.clone();\n\t\t\t\t\t\tline.close();\n\t\t\t\t\t\treturn line;\n\t\t\t\t\t}) as [GeometryLine, ...GeometryLine[]]);\n\t}\n\n\ttoJSON(): GeoJsonPolygon {\n\t\treturn {\n\t\t\ttype: \"Polygon\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonPolygon[\"coordinates\"] {\n\t\treturn this.polygon.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonPolygon[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryPolygon {\n\t\tif (!(geometry instanceof GeometryPolygon)) return false;\n\t\tif (this.polygon.length !== geometry.polygon.length) return false;\n\t\tfor (let i = 0; i < this.polygon.length; i++) {\n\t\t\tif (!this.polygon[i].is(geometry.polygon[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryPolygon {\n\t\treturn new GeometryPolygon(\n\t\t\tthis.polygon.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-point geometry value.\n */\nexport class GeometryMultiPoint extends Geometry {\n\treadonly points: [GeometryPoint, ...GeometryPoint[]];\n\n\tconstructor(\n\t\tpoints: [GeometryPoint, ...GeometryPoint[]] | GeometryMultiPoint,\n\t) {\n\t\tsuper();\n\t\tthis.points = points instanceof GeometryMultiPoint ? points.points : points;\n\t}\n\n\ttoJSON(): GeoJsonMultiPoint {\n\t\treturn {\n\t\t\ttype: \"MultiPoint\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiPoint[\"coordinates\"] {\n\t\treturn this.points.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiPoint[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiPoint {\n\t\tif (!(geometry instanceof GeometryMultiPoint)) return false;\n\t\tif (this.points.length !== geometry.points.length) return false;\n\t\tfor (let i = 0; i < this.points.length; i++) {\n\t\t\tif (!this.points[i].is(geometry.points[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiPoint {\n\t\treturn new GeometryMultiPoint(\n\t\t\tthis.points.map((p) => p.clone()) as [GeometryPoint, ...GeometryPoint[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-line geometry value.\n */\nexport class GeometryMultiLine extends Geometry {\n\treadonly lines: [GeometryLine, ...GeometryLine[]];\n\n\tconstructor(lines: [GeometryLine, ...GeometryLine[]] | GeometryMultiLine) {\n\t\tsuper();\n\t\tthis.lines = lines instanceof GeometryMultiLine ? lines.lines : lines;\n\t}\n\n\ttoJSON(): GeoJsonMultiLineString {\n\t\treturn {\n\t\t\ttype: \"MultiLineString\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiLineString[\"coordinates\"] {\n\t\treturn this.lines.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiLineString[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiLine {\n\t\tif (!(geometry instanceof GeometryMultiLine)) return false;\n\t\tif (this.lines.length !== geometry.lines.length) return false;\n\t\tfor (let i = 0; i < this.lines.length; i++) {\n\t\t\tif (!this.lines[i].is(geometry.lines[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiLine {\n\t\treturn new GeometryMultiLine(\n\t\t\tthis.lines.map((p) => p.clone()) as [GeometryLine, ...GeometryLine[]],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL multi-polygon geometry value.\n */\nexport class GeometryMultiPolygon extends Geometry {\n\treadonly polygons: [GeometryPolygon, ...GeometryPolygon[]];\n\n\tconstructor(\n\t\tpolygons: [GeometryPolygon, ...GeometryPolygon[]] | GeometryMultiPolygon,\n\t) {\n\t\tsuper();\n\t\tthis.polygons =\n\t\t\tpolygons instanceof GeometryMultiPolygon ? polygons.polygons : polygons;\n\t}\n\n\ttoJSON(): GeoJsonMultiPolygon {\n\t\treturn {\n\t\t\ttype: \"MultiPolygon\" as const,\n\t\t\tcoordinates: this.coordinates,\n\t\t};\n\t}\n\n\tget coordinates(): GeoJsonMultiPolygon[\"coordinates\"] {\n\t\treturn this.polygons.map(\n\t\t\t(g) => g.coordinates,\n\t\t) as GeoJsonMultiPolygon[\"coordinates\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryMultiPolygon {\n\t\tif (!(geometry instanceof GeometryMultiPolygon)) return false;\n\t\tif (this.polygons.length !== geometry.polygons.length) return false;\n\t\tfor (let i = 0; i < this.polygons.length; i++) {\n\t\t\tif (!this.polygons[i].is(geometry.polygons[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryMultiPolygon {\n\t\treturn new GeometryMultiPolygon(\n\t\t\tthis.polygons.map((p) => p.clone()) as [\n\t\t\t\tGeometryPolygon,\n\t\t\t\t...GeometryPolygon[],\n\t\t\t],\n\t\t);\n\t}\n}\n\n/**\n * A SurrealQL geometry collection value.\n */\nexport class GeometryCollection extends Geometry {\n\treadonly collection: [Geometry, ...Geometry[]];\n\n\tconstructor(collection: [Geometry, ...Geometry[]] | GeometryCollection) {\n\t\tsuper();\n\t\tthis.collection =\n\t\t\tcollection instanceof GeometryCollection\n\t\t\t\t? collection.collection\n\t\t\t\t: collection;\n\t}\n\n\ttoJSON(): GeoJsonCollection {\n\t\treturn {\n\t\t\ttype: \"GeometryCollection\" as const,\n\t\t\tgeometries: this.geometries,\n\t\t};\n\t}\n\n\tget geometries(): GeoJsonCollection[\"geometries\"] {\n\t\treturn this.collection.map((g) =>\n\t\t\tg.toJSON(),\n\t\t) as GeoJsonCollection[\"geometries\"];\n\t}\n\n\tis(geometry: Geometry): geometry is GeometryCollection {\n\t\tif (!(geometry instanceof GeometryCollection)) return false;\n\t\tif (this.collection.length !== geometry.collection.length) return false;\n\t\tfor (let i = 0; i < this.collection.length; i++) {\n\t\t\tif (!this.collection[i].is(geometry.collection[i])) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tclone(): GeometryCollection {\n\t\treturn new GeometryCollection(\n\t\t\tthis.collection.map((p) => p.clone()) as [Geometry, ...Geometry[]],\n\t\t);\n\t}\n}\n\n// Geo Json Types\n\ntype GeoJson =\n\t| GeoJsonPoint\n\t| GeoJsonLineString\n\t| GeoJsonPolygon\n\t| GeoJsonMultiPoint\n\t| GeoJsonMultiLineString\n\t| GeoJsonMultiPolygon\n\t| GeoJsonCollection;\n\nexport type GeoJsonPoint = {\n\ttype: \"Point\";\n\tcoordinates: [number, number];\n};\n\nexport type GeoJsonLineString = {\n\ttype: \"LineString\";\n\tcoordinates: [\n\t\tGeoJsonPoint[\"coordinates\"],\n\t\tGeoJsonPoint[\"coordinates\"],\n\t\t...GeoJsonPoint[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonPolygon = {\n\ttype: \"Polygon\";\n\tcoordinates: [\n\t\tGeoJsonLineString[\"coordinates\"],\n\t\t...GeoJsonLineString[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonMultiPoint = {\n\ttype: \"MultiPoint\";\n\tcoordinates: [GeoJsonPoint[\"coordinates\"], ...GeoJsonPoint[\"coordinates\"][]];\n};\n\nexport type GeoJsonMultiLineString = {\n\ttype: \"MultiLineString\";\n\tcoordinates: [\n\t\tGeoJsonLineString[\"coordinates\"],\n\t\t...GeoJsonLineString[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonMultiPolygon = {\n\ttype: \"MultiPolygon\";\n\tcoordinates: [\n\t\tGeoJsonPolygon[\"coordinates\"],\n\t\t...GeoJsonPolygon[\"coordinates\"][],\n\t];\n};\n\nexport type GeoJsonCollection = {\n\ttype: \"GeometryCollection\";\n\tgeometries: GeoJson[];\n};\n", "import { Value } from \"../data/value\";\n\n/**\n * Recursively compare supported SurrealQL values for equality.\n *\n * @param x The first value to compare\n * @param y The second value to compare\n * @returns Whether the two values are recursively equal\n */\nexport function equals(x: unknown, y: unknown): boolean {\n\tif (Object.is(x, y)) return true;\n\tif (x instanceof Date && y instanceof Date) {\n\t\treturn x.getTime() === y.getTime();\n\t}\n\tif (x instanceof RegExp && y instanceof RegExp) {\n\t\treturn x.toString() === y.toString();\n\t}\n\tif (x instanceof Value && y instanceof Value) {\n\t\treturn x.equals(y);\n\t}\n\tif (\n\t\ttypeof x !== \"object\" ||\n\t\tx === null ||\n\t\ttypeof y !== \"object\" ||\n\t\ty === null\n\t) {\n\t\treturn false;\n\t}\n\tconst keysX = Reflect.ownKeys(x as unknown as object) as (keyof typeof x)[];\n\tconst keysY = Reflect.ownKeys(y as unknown as object);\n\tif (keysX.length !== keysY.length) return false;\n\tfor (let i = 0; i < keysX.length; i++) {\n\t\tif (!Reflect.has(y as unknown as object, keysX[i])) return false;\n\t\tif (!equals(x[keysX[i]], y[keysX[i]])) return false;\n\t}\n\treturn true;\n}\n", "const MAX_i64 = 9223372036854775807n;\n/**\n * Escape a given string to be used as a valid SurrealQL ident.\n * @param str - The string to escape\n * @returns Optionally escaped string\n */\nexport function escapeIdent(str) {\n    // String which looks like a number should always be escaped, to prevent it from being parsed as a number\n    if (isOnlyNumbers(str)) {\n        return `\u27E8${str}\u27E9`;\n    }\n    // Empty string should always be escaped\n    if (str === \"\") {\n        return \"\u27E8\u27E9\";\n    }\n    let code;\n    let i;\n    let len;\n    for (i = 0, len = str.length; i < len; i++) {\n        code = str.charCodeAt(i);\n        if (!(code > 47 && code < 58) && // numeric (0-9)\n            !(code > 64 && code < 91) && // upper alpha (A-Z)\n            !(code > 96 && code < 123) && // lower alpha (a-z)\n            !(code === 95) // underscore (_)\n        ) {\n            return `\u27E8${str.replaceAll(\"\u27E9\", \"\\\\\u27E9\")}\u27E9`;\n        }\n    }\n    return str;\n}\n/**\n * Escape a given string to be used as a valid SurrealQL ident.\n * @param str - The string to escape\n * @returns Optionally escaped string\n * @deprecated Use `escapeIdent` instead\n */\nexport function escape_ident(str) {\n    return escapeIdent(str);\n}\n/**\n * Escape a number to be used as a valid SurrealQL ident.\n * @param num - The number to escape\n * @returns Optionally escaped number\n */\nexport function escapeNumber(num) {\n    return num <= MAX_i64 ? num.toString() : `\u27E8${num}\u27E9`;\n}\nfunction isOnlyNumbers(str) {\n    return /^\\d+$/.test(str.replace(/_/g, \"\"));\n}\n", "import { UUID, uuidv4obj, uuidv7obj } from \"uuidv7\";\nimport { Value } from \"../value\";\n\n/**\n * A SurrealQL UUID value.\n */\nexport class Uuid extends Value {\n\tprivate readonly inner: UUID;\n\n\tconstructor(uuid: string | ArrayBuffer | Uint8Array | Uuid | UUID) {\n\t\tsuper();\n\n\t\tif (uuid instanceof ArrayBuffer) {\n\t\t\tthis.inner = UUID.ofInner(new Uint8Array(uuid));\n\t\t} else if (uuid instanceof Uint8Array) {\n\t\t\tthis.inner = UUID.ofInner(uuid);\n\t\t} else if (uuid instanceof Uuid) {\n\t\t\tthis.inner = uuid.inner;\n\t\t} else if (uuid instanceof UUID) {\n\t\t\tthis.inner = uuid;\n\t\t} else {\n\t\t\tthis.inner = UUID.parse(uuid);\n\t\t}\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Uuid)) return false;\n\t\treturn this.inner.equals(other.inner);\n\t}\n\n\ttoString(): string {\n\t\treturn this.inner.toString();\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.inner.toString();\n\t}\n\n\ttoUint8Array(): Uint8Array {\n\t\treturn this.inner.bytes;\n\t}\n\n\ttoBuffer(): ArrayBufferLike {\n\t\treturn this.inner.bytes.buffer;\n\t}\n\n\tstatic v4(): Uuid {\n\t\treturn new Uuid(uuidv4obj());\n\t}\n\n\tstatic v7(): Uuid {\n\t\treturn new Uuid(uuidv7obj());\n\t}\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { equals } from \"../../util/equals\";\nimport { escapeIdent, escapeNumber } from \"../../util/escape\";\nimport { toSurrealqlString } from \"../../util/to-surrealql-string\";\nimport { Value } from \"../value\";\nimport { Uuid } from \"./uuid\";\n\nexport type RecordIdValue =\n\t| string\n\t| number\n\t| Uuid\n\t| bigint\n\t| unknown[]\n\t| Record<string, unknown>;\n\n/**\n * A SurrealQL record ID value.\n */\nexport class RecordId<Tb extends string = string> extends Value {\n\tpublic readonly tb: Tb;\n\tpublic readonly id: RecordIdValue;\n\n\tconstructor(tb: Tb, id: RecordIdValue) {\n\t\tsuper();\n\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"TB part is not valid\");\n\t\tif (!isValidIdPart(id)) throw new SurrealDbError(\"ID part is not valid\");\n\n\t\tthis.tb = tb;\n\t\tthis.id = id;\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof RecordId)) return false;\n\t\treturn this.tb === other.tb && equals(this.id, other.id);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst tb = escapeIdent(this.tb);\n\t\tconst id = escapeIdPart(this.id);\n\t\treturn `${tb}:${id}`;\n\t}\n}\n\n/**\n * A SurrealQL string-represented record ID value.\n */\nexport class StringRecordId extends Value {\n\tpublic readonly rid: string;\n\n\tconstructor(rid: string | StringRecordId | RecordId) {\n\t\tsuper();\n\n\t\t// In some cases the same method may be used with different data sources\n\t\t// this can cause this method to be called with an already instanced class object.\n\t\tif (rid instanceof StringRecordId) {\n\t\t\tthis.rid = rid.rid;\n\t\t} else if (rid instanceof RecordId) {\n\t\t\tthis.rid = rid.toString();\n\t\t} else if (typeof rid === \"string\") {\n\t\t\tthis.rid = rid;\n\t\t} else {\n\t\t\tthrow new SurrealDbError(\"String Record ID must be a string\");\n\t\t}\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof StringRecordId)) return false;\n\t\treturn this.rid === other.rid;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.rid;\n\t}\n\n\ttoString(): string {\n\t\treturn this.rid;\n\t}\n}\n\nexport function isValidIdPart(v: unknown): v is RecordIdValue {\n\tif (v instanceof Uuid) return true;\n\n\tswitch (typeof v) {\n\t\tcase \"string\":\n\t\tcase \"number\":\n\t\tcase \"bigint\":\n\t\t\treturn true;\n\t\tcase \"object\":\n\t\t\treturn Array.isArray(v) || v !== null;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport function escapeIdPart(id: RecordIdValue): string {\n\treturn id instanceof Uuid\n\t\t? `u\"${id}\"`\n\t\t: typeof id === \"string\"\n\t\t\t? escapeIdent(id)\n\t\t\t: typeof id === \"bigint\" || typeof id === \"number\"\n\t\t\t\t? escapeNumber(id)\n\t\t\t\t: toSurrealqlString(id);\n}\n", "import { SurrealDbError } from \"../../errors\";\nimport { Value } from \"../value\";\n\n/**\n * A SurrealQL table value.\n */\nexport class Table<Tb extends string = string> extends Value {\n\tpublic readonly tb: Tb;\n\n\tconstructor(tb: Tb) {\n\t\tsuper();\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"Table must be a string\");\n\t\tthis.tb = tb;\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Table)) return false;\n\t\treturn this.tb === other.tb;\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.tb;\n\t}\n\n\ttoString(): string {\n\t\treturn this.tb;\n\t}\n}\n", "import {\n\tDecimal,\n\tDuration,\n\tFuture,\n\tGeometry,\n\tRange,\n\tRecordId,\n\tStringRecordId,\n\tTable,\n\tUuid,\n} from \"../data\";\n\n/**\n * Recursively print any supported SurrealQL value into a string representation.\n * @param input - The input value\n * @returns Stringified SurrealQL representation\n */\nexport function toSurrealqlString(input: unknown): string {\n\tif (typeof input === \"string\") return `s${JSON.stringify(input)}`;\n\tif (input === null) return \"NULL\";\n\tif (input === undefined) return \"NONE\";\n\n\tif (typeof input === \"object\") {\n\t\t// We explicitely use string prefixes to ensure compability with both SurrealDB 1.x and 2.x\n\t\tif (input instanceof Date) return `d${JSON.stringify(input.toISOString())}`;\n\t\tif (input instanceof Uuid) return `u${JSON.stringify(input.toString())}`;\n\t\tif (input instanceof RecordId || input instanceof StringRecordId)\n\t\t\treturn `r${JSON.stringify(input.toString())}`;\n\n\t\tif (input instanceof Geometry) return toSurrealqlString(input.toJSON());\n\n\t\tif (\n\t\t\tinput instanceof Decimal ||\n\t\t\tinput instanceof Duration ||\n\t\t\tinput instanceof Future ||\n\t\t\tinput instanceof Range ||\n\t\t\tinput instanceof Table\n\t\t) {\n\t\t\treturn input.toJSON();\n\t\t}\n\n\t\t// We check by prototype, because we do not want to process derivatives of objects and arrays\n\t\tswitch (Object.getPrototypeOf(input)) {\n\t\t\tcase Object.prototype: {\n\t\t\t\tlet output = \"{ \";\n\t\t\t\tconst entries = Object.entries(input as object);\n\t\t\t\tfor (const [i, [k, v]] of entries.entries()) {\n\t\t\t\t\toutput += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`;\n\t\t\t\t\tif (i < entries.length - 1) output += \", \";\n\t\t\t\t}\n\t\t\t\toutput += \" }\";\n\t\t\t\treturn output;\n\t\t\t}\n\t\t\tcase Map.prototype: {\n\t\t\t\tlet output = \"{ \";\n\t\t\t\tconst entries = Array.from((input as Map<unknown, unknown>).entries());\n\t\t\t\tfor (const [i, [k, v]] of entries.entries()) {\n\t\t\t\t\toutput += `${JSON.stringify(k)}: ${toSurrealqlString(v)}`;\n\t\t\t\t\tif (i < entries.length - 1) output += \", \";\n\t\t\t\t}\n\t\t\t\toutput += \" }\";\n\t\t\t\treturn output;\n\t\t\t}\n\t\t\tcase Array.prototype: {\n\t\t\t\tconst array = (input as unknown[]).map(toSurrealqlString);\n\t\t\t\treturn `[ ${array.join(\", \")} ]`;\n\t\t\t}\n\t\t\tcase Set.prototype: {\n\t\t\t\tconst set = new Set([...(input as [])].map(toSurrealqlString));\n\t\t\t\treturn `[ ${[...set].join(\", \")} ]`;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn `${input}`;\n}\n", "import { Tagged } from \"../../cbor\";\nimport { SurrealDbError } from \"../../errors\";\nimport { equals } from \"../../util/equals\";\nimport { escapeIdent } from \"../../util/escape\";\nimport { toSurrealqlString } from \"../../util/to-surrealql-string\";\nimport { TAG_BOUND_EXCLUDED, TAG_BOUND_INCLUDED } from \"../cbor\";\nimport { Value } from \"../value\";\nimport { type RecordIdValue, escapeIdPart, isValidIdPart } from \"./recordid\";\n\n/**\n * A SurrealQL range value.\n */\nexport class Range<Beg, End> extends Value {\n\tconstructor(\n\t\treadonly beg: Bound<Beg>,\n\t\treadonly end: Bound<End>,\n\t) {\n\t\tsuper();\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof Range)) return false;\n\t\tif (this.beg?.constructor !== other.beg?.constructor) return false;\n\t\tif (this.end?.constructor !== other.end?.constructor) return false;\n\t\treturn (\n\t\t\tequals(this.beg?.value, other.beg?.value) &&\n\t\t\tequals(this.end?.value, other.end?.value)\n\t\t);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst beg = escapeRangeBound(this.beg);\n\t\tconst end = escapeRangeBound(this.end);\n\t\treturn `${beg}${getRangeJoin(this.beg, this.end)}${end}`;\n\t}\n}\n\nexport type Bound<T> = BoundIncluded<T> | BoundExcluded<T> | undefined;\nexport class BoundIncluded<T> {\n\tconstructor(readonly value: T) {}\n}\n\nexport class BoundExcluded<T> {\n\tconstructor(readonly value: T) {}\n}\n\n/**\n * A SurrealQL record ID range value.\n */\nexport class RecordIdRange<Tb extends string = string> extends Value {\n\tconstructor(\n\t\tpublic readonly tb: Tb,\n\t\tpublic readonly beg: Bound<RecordIdValue>,\n\t\tpublic readonly end: Bound<RecordIdValue>,\n\t) {\n\t\tsuper();\n\t\tif (typeof tb !== \"string\")\n\t\t\tthrow new SurrealDbError(\"TB part is not valid\");\n\t\tif (!isValidIdBound(beg)) throw new SurrealDbError(\"Beg part is not valid\");\n\t\tif (!isValidIdBound(end)) throw new SurrealDbError(\"End part is not valid\");\n\t}\n\n\tequals(other: unknown): boolean {\n\t\tif (!(other instanceof RecordIdRange)) return false;\n\t\tif (this.beg?.constructor !== other.beg?.constructor) return false;\n\t\tif (this.end?.constructor !== other.end?.constructor) return false;\n\t\treturn (\n\t\t\tthis.tb === other.tb &&\n\t\t\tequals(this.beg?.value, other.beg?.value) &&\n\t\t\tequals(this.end?.value, other.end?.value)\n\t\t);\n\t}\n\n\ttoJSON(): string {\n\t\treturn this.toString();\n\t}\n\n\ttoString(): string {\n\t\tconst tb = escapeIdent(this.tb);\n\t\tconst beg = escapeIdBound(this.beg);\n\t\tconst end = escapeIdBound(this.end);\n\t\treturn `${tb}:${beg}${getRangeJoin(this.beg, this.end)}${end}`;\n\t}\n}\n\nfunction getRangeJoin(beg: Bound<unknown>, end: Bound<unknown>): string {\n\tlet output = \"\";\n\tif (beg instanceof BoundExcluded) output += \">\";\n\toutput += \"..\";\n\tif (end instanceof BoundIncluded) output += \"=\";\n\treturn output;\n}\n\nfunction isValidIdBound(bound: Bound<unknown>): bound is Bound<RecordIdValue> {\n\treturn bound instanceof BoundIncluded || bound instanceof BoundExcluded\n\t\t? isValidIdPart(bound.value)\n\t\t: true;\n}\n\nfunction escapeIdBound(bound: Bound<RecordIdValue>): string {\n\treturn bound instanceof BoundIncluded || bound instanceof BoundExcluded\n\t\t? escapeIdPart(bound.value)\n\t\t: \"\";\n}\n\nfunction escapeRangeBound(bound: Bound<unknown>): string {\n\tif (bound === undefined) return \"\";\n\tconst value = bound.value;\n\n\tif (bound instanceof Range) return `(${toSurrealqlString(value)})`;\n\treturn toSurrealqlString(value);\n}\n\nexport function rangeToCbor([beg, end]: [Bound<unknown>, Bound<unknown>]): [\n\tTagged | null,\n\tTagged | null,\n] {\n\tfunction encodeBound(bound: Bound<unknown>): Tagged | null {\n\t\tif (bound instanceof BoundIncluded)\n\t\t\treturn new Tagged(TAG_BOUND_INCLUDED, bound.value);\n\t\tif (bound instanceof BoundExcluded)\n\t\t\treturn new Tagged(TAG_BOUND_EXCLUDED, bound.value);\n\t\treturn null;\n\t}\n\n\treturn [encodeBound(beg), encodeBound(end)];\n}\n\nexport function cborToRange(\n\trange: [Tagged | null, Tagged | null],\n): [Bound<unknown>, Bound<unknown>] {\n\tfunction decodeBound(bound: Tagged | null): Bound<unknown> {\n\t\tif (bound === null) return undefined;\n\t\tif (bound.tag === TAG_BOUND_INCLUDED) return new BoundIncluded(bound.value);\n\t\tif (bound.tag === TAG_BOUND_EXCLUDED) return new BoundExcluded(bound.value);\n\t\tthrow new SurrealDbError(\"Invalid bound tag\");\n\t}\n\n\treturn [decodeBound(range[0]), decodeBound(range[1])];\n}\n", "import { Tagged, decode, encode } from \"../cbor\";\nimport {\n\tcborCustomDateToDate,\n\tdateToCborCustomDate,\n} from \"./types/datetime.ts\";\nimport { Decimal } from \"./types/decimal.ts\";\nimport { Duration } from \"./types/duration.ts\";\nimport { Future } from \"./types/future.ts\";\nimport {\n\tGeometryCollection,\n\tGeometryLine,\n\tGeometryMultiLine,\n\tGeometryMultiPoint,\n\tGeometryMultiPolygon,\n\tGeometryPoint,\n\tGeometryPolygon,\n} from \"./types/geometry.ts\";\nimport {\n\tRange,\n\tRecordIdRange,\n\tcborToRange,\n\trangeToCbor,\n} from \"./types/range.ts\";\nimport { RecordId, StringRecordId } from \"./types/recordid.ts\";\nimport { Table } from \"./types/table.ts\";\nimport { Uuid } from \"./types/uuid.ts\";\n\n// Tags from the spec - https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml\nconst TAG_SPEC_DATETIME = 0;\nconst TAG_SPEC_UUID = 37;\n\n// Custom tags\nconst TAG_NONE = 6;\nconst TAG_TABLE = 7;\nconst TAG_RECORDID = 8;\nconst TAG_STRING_UUID = 9;\nconst TAG_STRING_DECIMAL = 10;\n// const TAG_BINARY_DECIMAL = 11;\nconst TAG_CUSTOM_DATETIME = 12;\nconst TAG_STRING_DURATION = 13;\nconst TAG_CUSTOM_DURATION = 14;\nconst TAG_FUTURE = 15;\n\n// Ranges\nexport const TAG_RANGE = 49;\nexport const TAG_BOUND_INCLUDED = 50;\nexport const TAG_BOUND_EXCLUDED = 51;\n\n// Custom Geometries\nconst TAG_GEOMETRY_POINT = 88;\nconst TAG_GEOMETRY_LINE = 89;\nconst TAG_GEOMETRY_POLYGON = 90;\nconst TAG_GEOMETRY_MULTIPOINT = 91;\nconst TAG_GEOMETRY_MULTILINE = 92;\nconst TAG_GEOMETRY_MULTIPOLYGON = 93;\nconst TAG_GEOMETRY_COLLECTION = 94;\n\nexport const replacer = {\n\tencode(v: unknown): unknown {\n\t\tif (v instanceof Date) {\n\t\t\treturn new Tagged(TAG_CUSTOM_DATETIME, dateToCborCustomDate(v));\n\t\t}\n\t\tif (v === undefined) return new Tagged(TAG_NONE, null);\n\t\tif (v instanceof Uuid) {\n\t\t\treturn new Tagged(TAG_SPEC_UUID, v.toBuffer());\n\t\t}\n\t\tif (v instanceof Decimal) {\n\t\t\treturn new Tagged(TAG_STRING_DECIMAL, v.toString());\n\t\t}\n\t\tif (v instanceof Duration) {\n\t\t\treturn new Tagged(TAG_CUSTOM_DURATION, v.toCompact());\n\t\t}\n\t\tif (v instanceof RecordId) {\n\t\t\treturn new Tagged(TAG_RECORDID, [v.tb, v.id]);\n\t\t}\n\t\tif (v instanceof StringRecordId) {\n\t\t\treturn new Tagged(TAG_RECORDID, v.rid);\n\t\t}\n\t\tif (v instanceof RecordIdRange) {\n\t\t\treturn new Tagged(TAG_RECORDID, [\n\t\t\t\tv.tb,\n\t\t\t\tnew Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end])),\n\t\t\t]);\n\t\t}\n\t\tif (v instanceof Table) return new Tagged(TAG_TABLE, v.tb);\n\t\tif (v instanceof Future) return new Tagged(TAG_FUTURE, v.inner);\n\t\tif (v instanceof Range)\n\t\t\treturn new Tagged(TAG_RANGE, rangeToCbor([v.beg, v.end]));\n\t\tif (v instanceof GeometryPoint) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_POINT, v.point);\n\t\t}\n\t\tif (v instanceof GeometryLine) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_LINE, v.line);\n\t\t}\n\t\tif (v instanceof GeometryPolygon) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_POLYGON, v.polygon);\n\t\t}\n\t\tif (v instanceof GeometryMultiPoint) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTIPOINT, v.points);\n\t\t}\n\t\tif (v instanceof GeometryMultiLine) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTILINE, v.lines);\n\t\t}\n\t\tif (v instanceof GeometryMultiPolygon) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_MULTIPOLYGON, v.polygons);\n\t\t}\n\t\tif (v instanceof GeometryCollection) {\n\t\t\treturn new Tagged(TAG_GEOMETRY_COLLECTION, v.collection);\n\t\t}\n\t\treturn v;\n\t},\n\tdecode(v: unknown): unknown {\n\t\tif (!(v instanceof Tagged)) return v;\n\n\t\tswitch (v.tag) {\n\t\t\tcase TAG_SPEC_DATETIME:\n\t\t\t\treturn new Date(v.value);\n\t\t\tcase TAG_SPEC_UUID:\n\t\t\tcase TAG_STRING_UUID:\n\t\t\t\treturn new Uuid(v.value);\n\t\t\tcase TAG_CUSTOM_DATETIME:\n\t\t\t\treturn cborCustomDateToDate(v.value);\n\t\t\tcase TAG_NONE:\n\t\t\t\treturn undefined;\n\t\t\tcase TAG_STRING_DECIMAL:\n\t\t\t\treturn new Decimal(v.value);\n\t\t\tcase TAG_STRING_DURATION:\n\t\t\t\treturn new Duration(v.value);\n\t\t\tcase TAG_CUSTOM_DURATION:\n\t\t\t\treturn Duration.fromCompact(v.value);\n\t\t\tcase TAG_TABLE:\n\t\t\t\treturn new Table(v.value);\n\t\t\tcase TAG_FUTURE:\n\t\t\t\treturn new Future(v.value);\n\t\t\tcase TAG_RANGE:\n\t\t\t\treturn new Range(...cborToRange(v.value));\n\t\t\tcase TAG_RECORDID: {\n\t\t\t\tif (v.value[1] instanceof Range) {\n\t\t\t\t\treturn new RecordIdRange(v.value[0], v.value[1].beg, v.value[1].end);\n\t\t\t\t}\n\t\t\t\treturn new RecordId(v.value[0], v.value[1]);\n\t\t\t}\n\t\t\tcase TAG_GEOMETRY_POINT:\n\t\t\t\treturn new GeometryPoint(v.value);\n\t\t\tcase TAG_GEOMETRY_LINE:\n\t\t\t\treturn new GeometryLine(v.value);\n\t\t\tcase TAG_GEOMETRY_POLYGON:\n\t\t\t\treturn new GeometryPolygon(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTIPOINT:\n\t\t\t\treturn new GeometryMultiPoint(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTILINE:\n\t\t\t\treturn new GeometryMultiLine(v.value);\n\t\t\tcase TAG_GEOMETRY_MULTIPOLYGON:\n\t\t\t\treturn new GeometryMultiPolygon(v.value);\n\t\t\tcase TAG_GEOMETRY_COLLECTION:\n\t\t\t\treturn new GeometryCollection(v.value);\n\t\t}\n\t},\n};\n\nObject.freeze(replacer);\n\n/**\n * Recursively encode any supported SurrealQL value into a binary CBOR representation.\n * @param data - The input value\n * @returns CBOR binary representation\n */\nexport function encodeCbor<T>(data: T): ArrayBuffer {\n\treturn encode(data, {\n\t\treplacer: replacer.encode,\n\t});\n}\n\n/**\n * Decode a CBOR encoded SurrealQL value into object representation.\n * @param data - The encoded SurrealQL value\n * @returns The parsed SurrealQL value\n */\n// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\nexport function decodeCbor(data: ArrayBufferLike): any {\n\treturn decode(data, {\n\t\treplacer: replacer.decode,\n\t});\n}\n", "import {\n\tEncoded,\n\ttype Fill,\n\tGap,\n\ttype PartiallyEncoded,\n\tWriter,\n\tencode,\n\tpartiallyEncodeObject,\n} from \"../cbor\";\nimport { replacer } from \"../data/cbor\";\n\nlet textEncoder: TextEncoder;\n\nexport type ConvertMethod<T = unknown> = (result: unknown[]) => T;\n\n/**\n * A query and its bindings prepared for execution, which can be passed to the .query() method.\n */\nexport class PreparedQuery {\n\tprivate _query: Uint8Array;\n\tprivate _bindings: Record<string, PartiallyEncoded>;\n\tprivate length: number;\n\n\tconstructor(query: string, bindings?: Record<string, unknown>) {\n\t\ttextEncoder ??= new TextEncoder();\n\t\tthis._query = textEncoder.encode(query);\n\t\tthis._bindings = partiallyEncodeObject(bindings ?? {}, {\n\t\t\treplacer: replacer.encode,\n\t\t});\n\t\tthis.length = Object.keys(this._bindings).length;\n\t}\n\n\t/**\n\t * Retrieves the encoded query string.\n\t */\n\tget query(): Encoded {\n\t\t// Up to 9 bytes for the prefix\n\t\tconst w = new Writer(this._query.byteLength + 9);\n\t\tw.writeMajor(3, this._query.byteLength);\n\t\tw.writeUint8Array(this._query);\n\t\treturn new Encoded(w.output(false));\n\t}\n\n\t/**\n\t * Retrieves the encoded bindings.\n\t */\n\tget bindings(): Record<string, PartiallyEncoded> {\n\t\treturn this._bindings;\n\t}\n\n\t/**\n\t * Compile this query and its bindings into a single ArrayBuffer, optionally filling gaps.\n\t * @param fills - The gap values to fill\n\t */\n\tbuild(fills?: Fill[]): ArrayBuffer {\n\t\treturn encode([this.query, this.bindings], { fills });\n\t}\n\n\t/**\n\t * A template literal tag function for appending additional query segments and bindings to the prepared query.\n\t * @param query_raw - The additional query segments to append\n\t * @param values - The additional interpolated values to append\n\t * @example\n\t * const query = surrealql`SELECT * FROM person`;\n\t *\n\t * if (filter) {\n\t *   query.append` WHERE name = ${filter}`;\n\t * }\n\t */\n\tappend(\n\t\tquery_raw: string[] | TemplateStringsArray,\n\t\t...values: unknown[]\n\t): PreparedQuery {\n\t\tconst base = this.length;\n\t\tthis.length += values.length;\n\n\t\tlet reused = 0;\n\t\tconst gaps = new Map<Gap, number>();\n\t\tconst mapped_bindings = values.map((v, i) => {\n\t\t\tif (v instanceof Gap) {\n\t\t\t\tconst index = gaps.get(v);\n\t\t\t\tif (index !== undefined) {\n\t\t\t\t\treused++;\n\t\t\t\t\treturn [`bind___${index}`, v] as const;\n\t\t\t\t}\n\n\t\t\t\tgaps.set(v, i - reused);\n\t\t\t}\n\n\t\t\treturn [`bind___${base + i - reused}`, v] as const;\n\t\t});\n\n\t\tfor (const [k, v] of mapped_bindings) {\n\t\t\tthis._bindings[k] = encode(v, {\n\t\t\t\treplacer: replacer.encode,\n\t\t\t\tpartial: true,\n\t\t\t});\n\t\t}\n\n\t\tconst query = query_raw\n\t\t\t.flatMap((segment, i) => {\n\t\t\t\tconst variable = mapped_bindings[i]?.[0];\n\t\t\t\treturn [segment, ...(variable ? [`$${variable}`] : [])];\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\ttextEncoder ??= new TextEncoder();\n\t\tconst current = new Uint8Array(this._query);\n\t\tconst added = textEncoder.encode(query);\n\t\tthis._query = new Uint8Array(current.byteLength + added.byteLength);\n\t\tthis._query.set(current);\n\t\tthis._query.set(added, current.byteLength);\n\t\treturn this;\n\t}\n}\n", "import { Gap } from \"../cbor/gap.ts\";\nimport { PreparedQuery } from \"./prepared-query.ts\";\n\n/**\n * A template literal tag function for creating prepared queries from query strings.\n * Interpolated values are automatically stored as bindings.\n * @param query_raw - The raw query string\n * @param values - The interpolated values\n * @example const query = surrealql`SELECT * FROM ${id}`;\n * @returns A PreparedQuery instance\n */\nexport function surrealql(\n\tquery_raw: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): PreparedQuery {\n\tlet reused = 0;\n\tconst gaps = new Map<Gap, number>();\n\tconst mapped_bindings = values.map((v, i) => {\n\t\tif (v instanceof Gap) {\n\t\t\tconst index = gaps.get(v);\n\t\t\tif (index !== undefined) {\n\t\t\t\treused++;\n\t\t\t\treturn [`bind___${index}`, v] as const;\n\t\t\t}\n\n\t\t\tgaps.set(v, i - reused);\n\t\t}\n\n\t\treturn [`bind___${i - reused}`, v] as const;\n\t});\n\n\tconst bindings = mapped_bindings.reduce<Record<`bind___${number}`, unknown>>(\n\t\t(prev, [k, v]) => {\n\t\t\tprev[k] = v;\n\t\t\treturn prev;\n\t\t},\n\t\t{},\n\t);\n\n\tconst query = query_raw\n\t\t.flatMap((segment, i) => {\n\t\t\tconst variable = mapped_bindings[i]?.[0];\n\t\t\treturn [segment, ...(variable ? [`$${variable}`] : [])];\n\t\t})\n\t\t.join(\"\");\n\n\treturn new PreparedQuery(query, bindings);\n}\n\nexport { surrealql as surql };\n", "import type { AuthController } from \"./auth\";\nimport type { Fill } from \"./cbor\";\nimport { type RecordId, Uuid } from \"./data\";\nimport { SurrealDbError } from \"./errors\";\nimport type { Surreal } from \"./surreal\";\nimport type { PreparedQuery } from \"./util/prepared-query\";\n\nexport type ActionResult<T extends Record<string, unknown>> = Prettify<\n\tT[\"id\"] extends RecordId ? T : { id: RecordId } & T\n>;\n\nexport type Prettify<T> = {\n\t[K in keyof T]: T[K];\n} & {}; // deno-lint-ignore ban-types\n\nexport type QueryParameters =\n\t| [query: string, bindings?: Record<string, unknown>]\n\t| [prepared: PreparedQuery, gaps?: Fill[]];\n\n//////////////////////////////////////////////\n//////////   AUTHENTICATION TYPES   //////////\n//////////////////////////////////////////////\n\nexport function convertAuth(params: AnyAuth): Record<string, unknown> {\n\tlet result: Record<string, unknown> = {};\n\tconst convertString = (a: string, b: string, optional?: boolean) => {\n\t\tif (a in params) {\n\t\t\tresult[b] = `${params[a as keyof AnyAuth]}`;\n\t\t\tdelete result[a];\n\t\t} else if (optional !== true) {\n\t\t\tthrow new SurrealDbError(\n\t\t\t\t`Key ${a} is missing from the authentication parameters`,\n\t\t\t);\n\t\t}\n\t};\n\n\tif (\"scope\" in params) {\n\t\tresult = { ...params };\n\t\tconvertString(\"scope\", \"sc\");\n\t\tconvertString(\"namespace\", \"ns\");\n\t\tconvertString(\"database\", \"db\");\n\t} else if (\"variables\" in params) {\n\t\tresult = { ...params.variables };\n\t\tconvertString(\"access\", \"ac\");\n\t\tconvertString(\"namespace\", \"ns\");\n\t\tconvertString(\"database\", \"db\");\n\t} else {\n\t\tconvertString(\"access\", \"ac\", true);\n\t\tconvertString(\"database\", \"db\", true);\n\t\tconvertString(\"namespace\", \"ns\", !(\"database\" in params));\n\t\tconvertString(\"username\", \"user\");\n\t\tconvertString(\"password\", \"pass\");\n\t}\n\n\treturn result;\n}\n\nexport type RootAuth = {\n\tusername: string;\n\tpassword: string;\n};\n\nexport type NamespaceAuth = {\n\tnamespace: string;\n\tusername: string;\n\tpassword: string;\n};\n\nexport type DatabaseAuth = {\n\tnamespace: string;\n\tdatabase: string;\n\tusername: string;\n\tpassword: string;\n};\n\nexport type AccessSystemAuth = Prettify<\n\t(RootAuth | NamespaceAuth | DatabaseAuth) & {\n\t\taccess: string;\n\t\tvariables?: never;\n\t}\n>;\n\nexport type ScopeAuth = {\n\tnamespace?: string;\n\tdatabase?: string;\n\tscope: string;\n\t[K: string]: unknown;\n};\n\nexport type AccessRecordAuth = {\n\tnamespace?: string;\n\tdatabase?: string;\n\taccess: string;\n\tvariables: {\n\t\tns?: never;\n\t\tdb?: never;\n\t\tac?: never;\n\t\t[K: string]: unknown;\n\t};\n};\n\nexport type AnyAuth =\n\t| RootAuth\n\t| NamespaceAuth\n\t| DatabaseAuth\n\t| ScopeAuth\n\t| AccessSystemAuth\n\t| AccessRecordAuth;\n\nexport type Token = string;\n\nexport type AuthClient = Pick<\n\tSurreal,\n\t\"signin\" | \"signup\" | \"authenticate\" | \"invalidate\"\n>;\n\n/////////////////////////////////////\n//////////   QUERY TYPES   //////////\n/////////////////////////////////////\n\nexport type QueryResult<T = unknown> = QueryResultOk<T> | QueryResultErr;\nexport type QueryResultOk<T> = {\n\tstatus: \"OK\";\n\ttime: string;\n\tresult: T;\n};\n\nexport type QueryResultErr = {\n\tstatus: \"ERR\";\n\ttime: string;\n\tresult: string;\n};\n\nexport type MapQueryResult<T> = {\n\t[K in keyof T]: QueryResult<T[K]>;\n};\n\n/////////////////////////////////////\n//////////   PATCH TYPES   //////////\n/////////////////////////////////////\n\ntype BasePatch<T = string> = {\n\tpath: T;\n};\n\nexport type AddPatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"add\";\n\tvalue: U;\n};\n\nexport type RemovePatch<T = string> = BasePatch<T> & {\n\top: \"remove\";\n};\n\nexport type ReplacePatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"replace\";\n\tvalue: U;\n};\n\nexport type ChangePatch<T = string, U = string> = BasePatch<T> & {\n\top: \"change\";\n\tvalue: U;\n};\n\nexport type CopyPatch<T = string, U = string> = BasePatch<T> & {\n\top: \"copy\";\n\tfrom: U;\n};\n\nexport type MovePatch<T = string, U = string> = BasePatch<T> & {\n\top: \"move\";\n\tfrom: U;\n};\n\nexport type TestPatch<T = string, U = unknown> = BasePatch<T> & {\n\top: \"test\";\n\tvalue: U;\n};\n\nexport type Patch =\n\t| AddPatch\n\t| RemovePatch\n\t| ReplacePatch\n\t| ChangePatch\n\t| CopyPatch\n\t| MovePatch\n\t| TestPatch;\n\n// RPC\n\nexport type RpcRequest<\n\tMethod extends string = string,\n\tParams extends unknown[] | undefined = unknown[],\n> = {\n\tmethod: Method;\n\tparams?: Params;\n};\n\nexport type RpcResponse<Result = unknown> =\n\t| RpcResponseOk<Result>\n\t| RpcResponseErr;\n\nexport type RpcResponseOk<Result = unknown> = {\n\tresult: Result;\n\terror?: never;\n};\n\nexport type RpcResponseErr = {\n\tresult?: never;\n\terror: {\n\t\tcode: number;\n\t\tmessage: string;\n\t};\n};\n\n// Live\n\nexport const liveActions = [\"CREATE\", \"UPDATE\", \"DELETE\"] as const;\nexport type LiveAction = (typeof liveActions)[number];\nexport type LiveResult = {\n\tid: Uuid;\n\taction: LiveAction;\n\tresult: Record<string, unknown>;\n};\n\nexport type LiveHandlerArguments<\n\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n> =\n\t| [action: LiveAction, result: Result]\n\t| [action: \"CLOSE\", result: \"killed\" | \"disconnected\"];\n\nexport type LiveHandler<\n\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n> = (...[action, result]: LiveHandlerArguments<Result>) => unknown;\n\nexport function isLiveResult(v: unknown): v is LiveResult {\n\tif (typeof v !== \"object\") return false;\n\tif (v === null) return false;\n\tif (!(\"id\" in v && \"action\" in v && \"result\" in v)) return false;\n\n\tif (!(v.id instanceof Uuid)) return false;\n\tif (!liveActions.includes(v.action as LiveAction)) return false;\n\tif (typeof v.result !== \"object\") return false;\n\tif (v.result === null) return false;\n\n\treturn true;\n}\n\n/////////////////////////////////////\n/////////   EXPORT TYPES   //////////\n/////////////////////////////////////\n\nexport type ExportOptions = {\n\tusers: boolean;\n\taccesses: boolean;\n\tparams: boolean;\n\tfunctions: boolean;\n\tanalyzers: boolean;\n\tversions: boolean;\n\ttables: boolean | string[];\n\trecords: boolean;\n};\n\n/////////////////////////////////////\n////////   CONNECT OPTIONS   ////////\n/////////////////////////////////////\n\nexport const DEFAULT_RECONNECT_OPTIONS: ReconnectOptions = {\n\tenabled: true,\n\tattempts: 5,\n\tretryDelay: 1000,\n\tretryDelayMax: 60000,\n\tretryDelayMultiplier: 2,\n\tretryDelayJitter: 0.1,\n};\n\nexport type PrepareFn = (auth: AuthController) => unknown;\n\nexport interface ConnectOptions {\n\t/** The namespace to connect to */\n\tnamespace?: string;\n\t/** The database to connect to */\n\tdatabase?: string;\n\t/** Authentication details to use */\n\tauth?: AnyAuth | Token;\n\t/** A callback to customise the connection before connection completion */\n\tprepare?: PrepareFn;\n\t/** Enable automated SurrealDB version checking */\n\tversionCheck?: boolean;\n\t/** The maximum amount of time in milliseconds to wait for version checking */\n\tversionCheckTimeout?: number;\n\t/** Configure reconnect behavior */\n\treconnect?: boolean | Partial<ReconnectOptions>;\n}\n\nexport interface ReconnectOptions {\n\t/** Reconnect after a connection has unexpectedly dropped */\n\tenabled: boolean;\n\t/** How many attempts will be made at reconnecting, -1 for unlimited */\n\tattempts: number;\n\t/** The minimum amount of time in milliseconds to wait before reconnecting */\n\tretryDelay: number;\n\t/** The maximum amount of time in milliseconds to wait before reconnecting */\n\tretryDelayMax: number;\n\t/** The amount to multiply the delay by after each failed attempt */\n\tretryDelayMultiplier: number;\n\t/** A float percentage to randomly offset each delay by  */\n\tretryDelayJitter: number;\n}\n", "import {\n\tDecimal,\n\tDuration,\n\tFuture,\n\tGeometry,\n\tRange,\n\tRecordId,\n\tRecordIdRange,\n\tStringRecordId,\n\tTable,\n\tUuid,\n} from \"../data\";\n\nexport type Jsonify<T> = T extends\n\t| Date\n\t| Uuid\n\t| Decimal\n\t| Duration\n\t| Future\n\t| Range<unknown, unknown>\n\t| StringRecordId\n\t? string\n\t: T extends undefined\n\t\t? never\n\t\t: T extends Record<string | number | symbol, unknown> | Array<unknown>\n\t\t\t? { [K in keyof T]: Jsonify<T[K]> }\n\t\t\t: T extends Map<infer K, infer V>\n\t\t\t\t? Map<K, Jsonify<V>>\n\t\t\t\t: T extends Set<infer V>\n\t\t\t\t\t? Set<Jsonify<V>>\n\t\t\t\t\t: T extends Geometry\n\t\t\t\t\t\t? ReturnType<T[\"toJSON\"]>\n\t\t\t\t\t\t: T extends RecordId<infer Tb>\n\t\t\t\t\t\t\t? `${Tb}:${string}`\n\t\t\t\t\t\t\t: T extends RecordIdRange<infer Tb>\n\t\t\t\t\t\t\t\t? `${Tb}:${string}..${string}`\n\t\t\t\t\t\t\t\t: T extends Table<infer Tb>\n\t\t\t\t\t\t\t\t\t? `${Tb}`\n\t\t\t\t\t\t\t\t\t: T;\n/**\n * Recursively convert any supported SurrealQL value into a serializable JSON representation.\n * @param input - The input value\n * @returns JSON-safe representation\n */\nexport function jsonify<T>(input: T): Jsonify<T> {\n\tif (typeof input === \"object\") {\n\t\tif (input === null) return null as Jsonify<T>;\n\n\t\t// We only want to process \"SurrealQL values\"\n\t\tif (\n\t\t\tinput instanceof Date ||\n\t\t\tinput instanceof Uuid ||\n\t\t\tinput instanceof Decimal ||\n\t\t\tinput instanceof Duration ||\n\t\t\tinput instanceof Future ||\n\t\t\tinput instanceof Range ||\n\t\t\tinput instanceof StringRecordId ||\n\t\t\tinput instanceof RecordIdRange ||\n\t\t\tinput instanceof RecordId ||\n\t\t\tinput instanceof Geometry ||\n\t\t\tinput instanceof Table\n\t\t) {\n\t\t\treturn input.toJSON() as Jsonify<T>;\n\t\t}\n\n\t\t// We check by prototype, because we do not want to process derivatives of objects and arrays\n\t\tswitch (Object.getPrototypeOf(input)) {\n\t\t\tcase Object.prototype: {\n\t\t\t\tconst entries = Object.entries(input as object);\n\t\t\t\tconst mapped = entries\n\t\t\t\t\t.map(([k, v]) => [k, jsonify(v)])\n\t\t\t\t\t.filter(([_, v]) => v !== undefined);\n\t\t\t\treturn Object.fromEntries(mapped) as Jsonify<T>;\n\t\t\t}\n\t\t\tcase Map.prototype: {\n\t\t\t\tconst entries = Array.from(input as [string, unknown][]);\n\t\t\t\tconst mapped = entries\n\t\t\t\t\t.map(([k, v]) => [k, jsonify(v)])\n\t\t\t\t\t.filter(([_, v]) => v !== undefined);\n\t\t\t\treturn new Map(mapped as [string, unknown][]) as Jsonify<T>;\n\t\t\t}\n\t\t\tcase Array.prototype:\n\t\t\t\treturn (input as []).map(jsonify) as Jsonify<T>;\n\t\t\tcase Set.prototype:\n\t\t\t\treturn new Set([...(input as [])].map(jsonify)) as Jsonify<T>;\n\t\t}\n\t}\n\n\treturn input as Jsonify<T>;\n}\n", "import { UnsupportedVersion, VersionRetrievalFailure } from \"../errors.ts\";\n\ntype Version = `${number}.${number}.${number}`;\nexport const defaultVersionCheckTimeout = 5000;\nexport const supportedSurrealDbVersionMin: Version = \"1.4.2\";\nexport const supportedSurrealDbVersionUntil: Version = \"3.0.0\";\nexport const supportedSurrealDbVersionRange: string = `>= ${supportedSurrealDbVersionMin} < ${supportedSurrealDbVersionUntil}`;\n\nexport function versionCheck(\n\tversion: string,\n\tmin: Version = supportedSurrealDbVersionMin,\n\tuntil: Version = supportedSurrealDbVersionUntil,\n): true {\n\tif (!isVersionSupported(version, min, until)) {\n\t\tthrow new UnsupportedVersion(version, `>= ${min} < ${until}`);\n\t}\n\n\treturn true;\n}\n\nexport function isVersionSupported(\n\tversion: string,\n\tmin: Version = supportedSurrealDbVersionMin,\n\tuntil: Version = supportedSurrealDbVersionUntil,\n): boolean {\n\treturn (\n\t\tmin.localeCompare(version, undefined, {\n\t\t\tnumeric: true,\n\t\t}) <= 0 &&\n\t\tuntil.localeCompare(version, undefined, {\n\t\t\tnumeric: true,\n\t\t}) === 1\n\t);\n}\n\n/**\n * Query the version of a remote SurrealDB instance\n * @param url - The URL of the remote SurrealDB instance\n * @param timeout - The timeout in milliseconds for the request\n * @returns\n */\nexport async function retrieveRemoteVersion(\n\turl: URL,\n\ttimeout?: number,\n): Promise<Version> {\n\tconst mappedProtocols = {\n\t\t\"ws:\": \"http:\",\n\t\t\"wss:\": \"https:\",\n\t\t\"http:\": \"http:\",\n\t\t\"https:\": \"https:\",\n\t} as Record<string, string>;\n\n\tconst protocol = mappedProtocols[url.protocol];\n\tif (protocol) {\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\t// biome-ignore lint/style/noParameterAssign: need to clone URL instance to prevent altering the original\n\t\turl = new URL(url);\n\t\turl.pathname = `${basepath}/version`;\n\t\turl.protocol = protocol;\n\n\t\tconst controller = new AbortController();\n\t\tconst id = setTimeout(\n\t\t\t() => controller.abort(),\n\t\t\ttimeout ?? defaultVersionCheckTimeout,\n\t\t);\n\t\tconst versionPrefix = \"surrealdb-\";\n\t\tconst version = await fetch(url, {\n\t\t\tsignal: controller.signal,\n\t\t})\n\t\t\t.then((res) => res.text())\n\t\t\t.then((version) => version.slice(versionPrefix.length))\n\t\t\t.catch((e) => {\n\t\t\t\tthrow new VersionRetrievalFailure(e);\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tclearTimeout(id);\n\t\t\t});\n\n\t\treturn version as Version;\n\t}\n\n\tthrow new VersionRetrievalFailure();\n}\n", "let id = 0;\nexport function getIncrementalID(): string {\n\tid = (id + 1) % Number.MAX_SAFE_INTEGER;\n\treturn id.toString();\n}\n", "import { StringRecordId, Uuid } from \"../data\";\n\n/**\n * A template literal tag function for parsing a string type\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed string\n */\nexport function s(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): string {\n\treturn string.reduce(\n\t\t(prev, curr, i) => `${prev}${curr}${values[i] ?? \"\"}`,\n\t\t\"\",\n\t);\n}\n\n/**\n * A template literal tag function for parsing a string into a Date\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed Date\n */\nexport function d(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): Date {\n\treturn new Date(s(string, values));\n}\n\n/**\n * A template literal tag function for parsing a string into a StringRecordId\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed StringRecordId\n */\nexport function r(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): StringRecordId {\n\treturn new StringRecordId(s(string, values));\n}\n\n/**\n * A template literal tag function for parsing a string into a Uuid\n * @param string - The string to parse\n * @param values - The interpolated values\n * @returns The parsed Uuid\n */\nexport function u(\n\tstring: string[] | TemplateStringsArray,\n\t...values: unknown[]\n): Uuid {\n\treturn new Uuid(s(string, values));\n}\n", "import type { EngineDisconnected } from \"../errors\";\nimport type {\n\tExportOptions,\n\tLiveHandlerArguments,\n\tPrepareFn,\n\tRpcRequest,\n\tRpcResponse,\n} from \"../types\";\nimport type { Emitter } from \"../util/emitter\";\nimport type { ReconnectContext } from \"../util/reconnect\";\n\nexport type Engine = new (context: EngineContext) => AbstractEngine;\nexport type Engines = Record<string, Engine>;\nexport const RetryMessage: unique symbol = Symbol(\"RetryMessage\");\n\nexport type EngineEvents = {\n\tconnecting: [];\n\tconnected: [];\n\treconnecting: [];\n\tdisconnected: [];\n\terror: [Error];\n\n\t[K: `rpc-${string | number}`]: [\n\t\tRpcResponse | EngineDisconnected | typeof RetryMessage,\n\t];\n\t[K: `live-${string}`]: LiveHandlerArguments;\n};\n\nexport enum ConnectionStatus {\n\tDisconnected = \"disconnected\",\n\tConnecting = \"connecting\",\n\tReconnecting = \"reconnecting\",\n\tConnected = \"connected\",\n\tError = \"error\",\n}\n\nexport class EngineContext {\n\treadonly emitter: Emitter<EngineEvents>;\n\treadonly encodeCbor: (value: unknown) => ArrayBuffer;\n\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\treadonly decodeCbor: (value: ArrayBufferLike) => any;\n\treadonly reconnect: ReconnectContext;\n\treadonly prepare: PrepareFn | undefined;\n\n\tconstructor({\n\t\temitter,\n\t\tencodeCbor,\n\t\tdecodeCbor,\n\t\treconnect,\n\t\tprepare,\n\t}: {\n\t\temitter: Emitter<EngineEvents>;\n\t\tencodeCbor: (value: unknown) => ArrayBuffer;\n\t\t// biome-ignore lint/suspicious/noExplicitAny: Don't know what it will return\n\t\tdecodeCbor: (value: ArrayBufferLike) => any;\n\t\treconnect: ReconnectContext;\n\t\tprepare: PrepareFn | undefined;\n\t}) {\n\t\tthis.emitter = emitter;\n\t\tthis.encodeCbor = encodeCbor;\n\t\tthis.decodeCbor = decodeCbor;\n\t\tthis.reconnect = reconnect;\n\t\tthis.prepare = prepare;\n\t}\n}\n\nexport abstract class AbstractEngine {\n\treadonly context: EngineContext;\n\tready: Promise<void> | undefined;\n\tstatus: ConnectionStatus = ConnectionStatus.Disconnected;\n\tconnection: {\n\t\turl: URL | undefined;\n\t\tnamespace: string | undefined;\n\t\tdatabase: string | undefined;\n\t\ttoken: string | undefined;\n\t} = {\n\t\turl: undefined,\n\t\tnamespace: undefined,\n\t\tdatabase: undefined,\n\t\ttoken: undefined,\n\t};\n\n\tconstructor(context: EngineContext) {\n\t\tthis.context = context;\n\t}\n\n\tget emitter(): EngineContext[\"emitter\"] {\n\t\treturn this.context.emitter;\n\t}\n\n\tget encodeCbor(): EngineContext[\"encodeCbor\"] {\n\t\treturn this.context.encodeCbor;\n\t}\n\n\tget decodeCbor(): EngineContext[\"decodeCbor\"] {\n\t\treturn this.context.decodeCbor;\n\t}\n\n\tabstract connect(url: URL): Promise<void>;\n\tabstract disconnect(): Promise<void>;\n\tabstract rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(request: RpcRequest<Method, Params>): Promise<RpcResponse<Result>>;\n\n\tabstract version(url: URL, timeout?: number): Promise<string>;\n\tabstract export(options?: Partial<ExportOptions>): Promise<string>;\n\tabstract import(data: string): Promise<void>;\n\n\t// protected authClient(): AuthClient {\n\t// \tconst self = this;\n\n\t// \treturn {\n\t// \t\tasync signup(vars: ScopeAuth | AccessRecordAuth): Promise<Token> {\n\t// \t\t\tconst parsed = processAuthVars(vars, self.connection);\n\t// \t\t\tconst converted = convertAuth(parsed);\n\t// \t\t\tconst res: RpcResponse<Token> = await self.rpc({\n\t// \t\t\t\tmethod: \"signup\",\n\t// \t\t\t\tparams: [converted],\n\t// \t\t\t});\n\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\tif (!res.result) {\n\t// \t\t\t\tthrow new NoTokenReturned();\n\t// \t\t\t}\n\n\t// \t\t\treturn res.result;\n\t// \t\t}\n\n\t// \t\tasync signin(vars: AnyAuth): Promise<Token> {\n\t// \t\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t// \t\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t// \t\t\tconst converted = convertAuth(parsed);\n\t// \t\t\tconst res = await this.rpc<Token>(\"signin\", [converted]);\n\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\tif (!res.result) {\n\t// \t\t\t\tthrow new NoTokenReturned();\n\t// \t\t\t}\n\n\t// \t\t\treturn res.result;\n\t// \t\t}\n\n\t// \t\tasync authenticate(token: Token): Promise<true> {\n\t// \t\t\tconst res = await this.rpc<string>(\"authenticate\", [token]);\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\treturn true;\n\t// \t\t}\n\n\t// \t\tasync invalidate(): Promise<true> {\n\t// \t\t\tconst res = await this.rpc(\"invalidate\");\n\t// \t\t\tif (res.error) throw new ResponseError(res.error.message);\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n", "import { NoDatabaseSpecified, NoNamespaceSpecified } from \"../errors.ts\";\nimport type { AnyAuth } from \"../types.ts\";\n\nexport function processAuthVars<T extends AnyAuth>(\n\tvars: T,\n\tfallback?: {\n\t\tnamespace?: string;\n\t\tdatabase?: string;\n\t},\n): AnyAuth {\n\tif (\n\t\t\"scope\" in vars ||\n\t\t(\"access\" in vars && \"variables\" in vars && vars.variables)\n\t) {\n\t\tif (!vars.namespace) {\n\t\t\tif (!fallback?.namespace) throw new NoNamespaceSpecified();\n\t\t\tvars.namespace = fallback.namespace;\n\t\t}\n\n\t\tif (!vars.database) {\n\t\t\tif (!fallback?.database) throw new NoDatabaseSpecified();\n\t\t\tvars.database = fallback.database;\n\t\t}\n\t}\n\n\treturn vars;\n}\n", "import type { AbstractEngine } from \"./engines/abstract\";\nimport { NoActiveSocket, NoTokenReturned, ResponseError } from \"./errors\";\nimport {\n\ttype AccessRecordAuth,\n\ttype AnyAuth,\n\ttype RpcResponse,\n\ttype ScopeAuth,\n\ttype Token,\n\tconvertAuth,\n} from \"./types\";\nimport { processAuthVars } from \"./util/process-auth-vars\";\n\nexport abstract class AuthController {\n\tabstract connection: AbstractEngine | undefined;\n\n\tabstract rpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>>;\n\n\t/**\n\t * Signs up to a specific authentication scope.\n\t * @param vars - Variables used in a signup query.\n\t * @return The authentication token.\n\t */\n\tasync signup(vars: ScopeAuth | AccessRecordAuth): Promise<Token> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t\tconst converted = convertAuth(parsed);\n\t\tconst res = await this.rpc<Token>(\"signup\", [converted]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (!res.result) {\n\t\t\tthrow new NoTokenReturned();\n\t\t}\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Signs in to a specific authentication scope.\n\t * @param vars - Variables used in a signin query.\n\t * @return The authentication token.\n\t */\n\tasync signin(vars: AnyAuth): Promise<Token> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tconst parsed = processAuthVars(vars, this.connection.connection);\n\t\tconst converted = convertAuth(parsed);\n\t\tconst res = await this.rpc<Token>(\"signin\", [converted]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (!res.result) {\n\t\t\tthrow new NoTokenReturned();\n\t\t}\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Authenticates the current connection with a JWT token.\n\t * @param token - The JWT authentication token.\n\t */\n\tasync authenticate(token: Token): Promise<true> {\n\t\tconst res = await this.rpc<string>(\"authenticate\", [token]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Invalidates the authentication for the current connection.\n\t */\n\tasync invalidate(): Promise<true> {\n\t\tconst res = await this.rpc(\"invalidate\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n}\n\nexport class EngineAuth extends AuthController {\n\tconstructor(public connection: AbstractEngine) {\n\t\tsuper();\n\t}\n\n\trpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\treturn this.connection.rpc<typeof method, typeof params, Result>({\n\t\t\tmethod,\n\t\t\tparams,\n\t\t});\n\t}\n}\n", "import { HttpConnectionError } from \"../errors\";\nimport { AbstractEngine } from \"./abstract\";\n\nexport abstract class AbstractRemoteEngine extends AbstractEngine {\n\tprotected async req_post(\n\t\tbody: unknown,\n\t\turl?: URL,\n\t\theaders_?: Record<string, string>,\n\t): Promise<ArrayBuffer> {\n\t\tconst headers: Record<string, string> = {\n\t\t\t\"Content-Type\": \"application/cbor\",\n\t\t\tAccept: \"application/cbor\",\n\t\t\t...headers_,\n\t\t};\n\n\t\tif (this.connection.namespace) {\n\t\t\theaders[\"Surreal-NS\"] = this.connection.namespace;\n\t\t}\n\n\t\tif (this.connection.database) {\n\t\t\theaders[\"Surreal-DB\"] = this.connection.database;\n\t\t}\n\n\t\tif (this.connection.token) {\n\t\t\theaders.Authorization = `Bearer ${this.connection.token}`;\n\t\t}\n\n\t\tconst raw = await fetch(`${url ?? this.connection.url}`, {\n\t\t\tmethod: \"POST\",\n\t\t\theaders,\n\t\t\tbody: this.encodeCbor(body),\n\t\t});\n\n\t\tconst buffer = await raw.arrayBuffer();\n\n\t\tif (raw.status === 200) {\n\t\t\treturn buffer;\n\t\t}\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\tthrow new HttpConnectionError(\n\t\t\tdec.decode(buffer),\n\t\t\traw.status,\n\t\t\traw.statusText,\n\t\t\tbuffer,\n\t\t);\n\t}\n}\n", "import { EngineAuth } from \"../auth\";\nimport { ConnectionUnavailable, MissingNamespaceDatabase } from \"../errors\";\nimport type { ExportOptions, RpcRequest, RpcResponse } from \"../types\";\nimport { getIncrementalID } from \"../util/get-incremental-id\";\nimport { retrieveRemoteVersion } from \"../util/version-check\";\nimport { ConnectionStatus, type EngineEvents } from \"./abstract\";\nimport { AbstractRemoteEngine } from \"./abstract-remote\";\n\nconst ALWAYS_ALLOW = new Set([\n\t\"signin\",\n\t\"signup\",\n\t\"authenticate\",\n\t\"invalidate\",\n\t\"version\",\n\t\"use\",\n\t\"let\",\n\t\"unset\",\n\t\"query\",\n]);\n\nexport class HttpEngine extends AbstractRemoteEngine {\n\tconnection: {\n\t\turl: URL | undefined;\n\t\tnamespace: string | undefined;\n\t\tdatabase: string | undefined;\n\t\ttoken: string | undefined;\n\t\tvariables: Record<string, unknown>;\n\t} = {\n\t\turl: undefined,\n\t\tnamespace: undefined,\n\t\tdatabase: undefined,\n\t\ttoken: undefined,\n\t\tvariables: {},\n\t};\n\n\tprivate setStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t\t...args: EngineEvents[T]\n\t) {\n\t\tthis.status = status;\n\t\tthis.emitter.emit(status, args);\n\t}\n\n\tversion(url: URL, timeout?: number): Promise<string> {\n\t\treturn retrieveRemoteVersion(url, timeout);\n\t}\n\n\tasync connect(url: URL): Promise<void> {\n\t\tthis.setStatus(ConnectionStatus.Connecting);\n\t\tthis.connection.url = url;\n\t\tawait this.context.prepare?.(new EngineAuth(this));\n\t\tthis.setStatus(ConnectionStatus.Connected);\n\t\tthis.ready = new Promise<void>((r) => r());\n\t\treturn this.ready;\n\t}\n\n\tdisconnect(): Promise<void> {\n\t\tthis.connection = {\n\t\t\turl: undefined,\n\t\t\tnamespace: undefined,\n\t\t\tdatabase: undefined,\n\t\t\ttoken: undefined,\n\t\t\tvariables: {},\n\t\t};\n\n\t\tthis.ready = undefined;\n\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\t\treturn new Promise<void>((r) => r());\n\t}\n\n\tasync rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(request: RpcRequest<Method, Params>): Promise<RpcResponse<Result>> {\n\t\tawait this.ready;\n\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\n\t\tif (\n\t\t\t(!this.connection.namespace || !this.connection.database) &&\n\t\t\t!ALWAYS_ALLOW.has(request.method)\n\t\t) {\n\t\t\tthrow new MissingNamespaceDatabase();\n\t\t}\n\n\t\tif (request.method === \"use\") {\n\t\t\tconst [ns, db] = request.params as [\n\t\t\t\tstring | null | undefined,\n\t\t\t\tstring | null | undefined,\n\t\t\t];\n\n\t\t\tif (ns === null) this.connection.namespace = undefined;\n\t\t\tif (db === null) this.connection.database = undefined;\n\t\t\tif (ns) this.connection.namespace = ns;\n\t\t\tif (db) this.connection.database = db;\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"let\") {\n\t\t\tconst [key, value] = request.params as [string, unknown];\n\t\t\tthis.connection.variables[key] = value;\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"unset\") {\n\t\t\tconst [key] = request.params as [string];\n\t\t\tdelete this.connection.variables[key];\n\t\t\treturn {\n\t\t\t\tresult: true as Result,\n\t\t\t};\n\t\t}\n\n\t\tif (request.method === \"query\") {\n\t\t\trequest.params = [\n\t\t\t\trequest.params?.[0],\n\t\t\t\t{\n\t\t\t\t\t...this.connection.variables,\n\t\t\t\t\t...(request.params?.[1] ?? {}),\n\t\t\t\t},\n\t\t\t] as Params;\n\t\t}\n\n\t\tconst id = getIncrementalID();\n\t\tconst buffer = await this.req_post({ id, ...request });\n\t\tconst response: RpcResponse = this.decodeCbor(buffer);\n\n\t\tif (\"result\" in response) {\n\t\t\tswitch (request.method) {\n\t\t\t\tcase \"signin\":\n\t\t\t\tcase \"signup\": {\n\t\t\t\t\tthis.connection.token = response.result as string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"authenticate\": {\n\t\t\t\t\tconst [token] = request.params as [string];\n\t\t\t\t\tthis.connection.token = token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"invalidate\": {\n\t\t\t\t\tthis.connection.token = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.emitter.emit(`rpc-${id}`, [response]);\n\t\treturn response as RpcResponse<Result>;\n\t}\n\n\tget connected(): boolean {\n\t\treturn !!this.connection.url;\n\t}\n\n\tasync export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.pathname = `${basepath}/export`;\n\n\t\tconst buffer = await this.req_post(options ?? {}, url, {\n\t\t\tAccept: \"plain/text\",\n\t\t});\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\treturn dec.decode(buffer);\n\t}\n\n\tasync import(data: string): Promise<void> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.pathname = `${basepath}/import`;\n\n\t\tawait this.req_post(data, url, {\n\t\t\tAccept: \"application/json\",\n\t\t});\n\t}\n}\n", "import { WebSocket } from \"isows\";\nimport { EngineAuth } from \"../auth\";\nimport {\n\tConnectionUnavailable,\n\tEngineDisconnected,\n\tNoURLProvided,\n\tReconnectFailed,\n\tResponseError,\n\tUnexpectedConnectionError,\n\tUnexpectedServerResponse,\n} from \"../errors\";\nimport {\n\ttype ExportOptions,\n\ttype RpcRequest,\n\ttype RpcResponse,\n\tisLiveResult,\n} from \"../types\";\nimport { type Completable, newCompletable } from \"../util/completable\";\nimport { getIncrementalID } from \"../util/get-incremental-id\";\nimport { retrieveRemoteVersion } from \"../util/version-check\";\nimport {\n\tConnectionStatus,\n\ttype EngineContext,\n\ttype EngineEvents,\n\tRetryMessage,\n} from \"./abstract\";\nimport { AbstractRemoteEngine } from \"./abstract-remote\";\n\nexport class WebsocketEngine extends AbstractRemoteEngine {\n\tprivate pinger?: Pinger;\n\tprivate socket?: WebSocket;\n\tprivate disconnected: Completable;\n\n\tconstructor(ctx: EngineContext) {\n\t\tsuper(ctx);\n\t\tthis.disconnected = newCompletable();\n\t}\n\n\tprivate setStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t\t...args: EngineEvents[T]\n\t) {\n\t\tif (\n\t\t\t(this.connection.url && status === ConnectionStatus.Disconnected) ||\n\t\t\tstatus === ConnectionStatus.Error\n\t\t) {\n\t\t\tthis.disconnected.resolve();\n\t\t\tthis.disconnected = newCompletable();\n\t\t} else {\n\t\t\tthis.status = status;\n\t\t\tthis.emitter.emit(status, args);\n\t\t}\n\t}\n\n\tprivate async requireStatus<T extends ConnectionStatus>(\n\t\tstatus: T,\n\t): Promise<true> {\n\t\tif (this.status !== status) {\n\t\t\tawait this.emitter.subscribeOnce(status);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tversion(url: URL, timeout?: number): Promise<string> {\n\t\treturn retrieveRemoteVersion(url, timeout);\n\t}\n\n\tasync connect(url: URL): Promise<void> {\n\t\tthis.connection.url = url;\n\n\t\t// Create an async loop\n\t\t(async () => {\n\t\t\tlet initial = true;\n\t\t\tlet controls: [() => void, (reason?: Error) => void] | undefined =\n\t\t\t\tundefined;\n\n\t\t\twhile (this.connection.url) {\n\t\t\t\tif (initial) {\n\t\t\t\t\tinitial = false;\n\t\t\t\t\tthis.setStatus(ConnectionStatus.Connecting);\n\t\t\t\t\tthis.ready = this.createSocket();\n\t\t\t\t\tawait this.disconnected.promise;\n\t\t\t\t} else {\n\t\t\t\t\t// Check if reconnecting is enabled\n\t\t\t\t\tif (!this.context.reconnect.enabled) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Configure controls for the promise if they are currently lacking\n\t\t\t\t\tif (!controls) {\n\t\t\t\t\t\tconst { promise, resolve, reject } = newCompletable();\n\t\t\t\t\t\tthis.ready = promise;\n\t\t\t\t\t\tcontrols = [resolve, reject];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Obtain the controls for the promise\n\t\t\t\t\tconst [resolve, reject] = controls;\n\n\t\t\t\t\t// Check if we will be allowed to iterate\n\t\t\t\t\tif (!this.context.reconnect.allowed) {\n\t\t\t\t\t\t// Clear the engine\n\t\t\t\t\t\tthis.connection = {\n\t\t\t\t\t\t\turl: undefined,\n\t\t\t\t\t\t\tnamespace: undefined,\n\t\t\t\t\t\t\tdatabase: undefined,\n\t\t\t\t\t\t\ttoken: undefined,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.socket = undefined;\n\t\t\t\t\t\treject(new ReconnectFailed());\n\n\t\t\t\t\t\t// Emit the ReconnectFailed error\n\t\t\t\t\t\tthis.emitter.emit(ConnectionStatus.Error, [new ReconnectFailed()]);\n\n\t\t\t\t\t\t// Emit the status\n\t\t\t\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\n\t\t\t\t\t\t// Break the loop\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Emit the status\n\t\t\t\t\tthis.setStatus(ConnectionStatus.Reconnecting);\n\n\t\t\t\t\t// Try to iterate\n\t\t\t\t\tawait this.context.reconnect.iterate();\n\n\t\t\t\t\t// Attempt to reconnect\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait this.createSocket();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// Ignore any error\n\t\t\t\t\t\t// the connection failed, let's try again\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Reconfigure the namespace and database\n\t\t\t\t\t\tif (this.connection.namespace || this.connection.database) {\n\t\t\t\t\t\t\tconst res = await this.rpc(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmethod: \"use\",\n\t\t\t\t\t\t\t\t\tparams: [this.connection.namespace, this.connection.database],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\t\t\tthrow new ResponseError(res.error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Reconfigure the authentication details\n\t\t\t\t\t\tif (this.connection.token) {\n\t\t\t\t\t\t\tconst res = await this.rpc(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmethod: \"authenticate\",\n\t\t\t\t\t\t\t\t\tparams: [this.connection.token],\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\t\t\tthrow new ResponseError(res.error.message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// Clear the engine\n\t\t\t\t\t\tthis.connection = {\n\t\t\t\t\t\t\turl: undefined,\n\t\t\t\t\t\t\tnamespace: undefined,\n\t\t\t\t\t\t\tdatabase: undefined,\n\t\t\t\t\t\t\ttoken: undefined,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.socket = undefined;\n\t\t\t\t\t\treject(e as Error);\n\n\t\t\t\t\t\t// Emit the ReconnectFailed error\n\t\t\t\t\t\tthis.emitter.emit(ConnectionStatus.Error, [e as Error]);\n\n\t\t\t\t\t\t// Emit the status\n\t\t\t\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset the reconnection status\n\t\t\t\t\tthis.context.reconnect.reset();\n\n\t\t\t\t\t// Unblock the connection\n\t\t\t\t\tresolve();\n\n\t\t\t\t\t// Scan all pending rpc requests\n\t\t\t\t\tconst pending = this.emitter.scanListeners((k) =>\n\t\t\t\t\t\tk.startsWith(\"rpc-\"),\n\t\t\t\t\t);\n\t\t\t\t\t// Ensure all rpc requests receive a retry symbol\n\t\t\t\t\tpending.map((k) => this.emitter.emit(k, [RetryMessage]));\n\n\t\t\t\t\t// If we are connection, wait for the connection to be dropped\n\t\t\t\t\tif (this.status === ConnectionStatus.Connected) {\n\t\t\t\t\t\tawait this.disconnected.promise;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\n\t\tawait this.ready;\n\t}\n\n\tprivate async createSocket() {\n\t\tconst { promise, resolve, reject } = newCompletable();\n\n\t\t// Validate requirements\n\t\tif (!this.connection.url) {\n\t\t\tthrow new NoURLProvided();\n\t\t}\n\n\t\t// Open a new connection\n\t\tconst socket = new WebSocket(this.connection.url.toString(), \"cbor\");\n\n\t\t// Wait for the connection to open\n\t\tsocket.addEventListener(\"open\", async () => {\n\t\t\tawait this.context.prepare?.(new EngineAuth(this));\n\t\t\tthis.setStatus(ConnectionStatus.Connected);\n\t\t\tresolve();\n\t\t});\n\n\t\t// Handle any errors\n\t\tsocket.addEventListener(\"error\", (e) => {\n\t\t\tconst error = new UnexpectedConnectionError(\n\t\t\t\t\"detail\" in e && e.detail\n\t\t\t\t\t? e.detail\n\t\t\t\t\t: \"message\" in e && e.message\n\t\t\t\t\t\t? e.message\n\t\t\t\t\t\t: \"error\" in e && e.error\n\t\t\t\t\t\t\t? e.error\n\t\t\t\t\t\t\t: \"An unexpected error occurred\",\n\t\t\t);\n\t\t\tthis.setStatus(ConnectionStatus.Error, error);\n\t\t\treject(error);\n\t\t});\n\n\t\t// Handle connection closure\n\t\tsocket.addEventListener(\"close\", () => {\n\t\t\tthis.setStatus(ConnectionStatus.Disconnected);\n\t\t\tthis.pinger?.stop();\n\t\t});\n\n\t\t// Handle any messages\n\t\tsocket.addEventListener(\"message\", async ({ data }) => {\n\t\t\ttry {\n\t\t\t\tconst decoded = this.decodeCbor(\n\t\t\t\t\tdata instanceof ArrayBuffer\n\t\t\t\t\t\t? data\n\t\t\t\t\t\t: data instanceof Blob\n\t\t\t\t\t\t\t? await data.arrayBuffer()\n\t\t\t\t\t\t\t: data.buffer.slice(\n\t\t\t\t\t\t\t\t\tdata.byteOffset,\n\t\t\t\t\t\t\t\t\tdata.byteOffset + data.byteLength,\n\t\t\t\t\t\t\t\t),\n\t\t\t\t);\n\n\t\t\t\tif (\n\t\t\t\t\ttypeof decoded === \"object\" &&\n\t\t\t\t\tdecoded != null &&\n\t\t\t\t\tObject.getPrototypeOf(decoded) === Object.prototype\n\t\t\t\t) {\n\t\t\t\t\tthis.handleRpcResponse(decoded);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new UnexpectedServerResponse(decoded);\n\t\t\t\t}\n\t\t\t} catch (detail) {\n\t\t\t\tsocket.dispatchEvent(new CustomEvent(\"error\", { detail }));\n\t\t\t}\n\t\t});\n\n\t\tawait promise.then(() => {\n\t\t\tthis.socket = socket;\n\t\t\tthis.pinger?.stop();\n\t\t\tthis.pinger = new Pinger(30000);\n\t\t\tthis.pinger.start(() => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.rpc({ method: \"ping\" });\n\t\t\t\t} catch {\n\t\t\t\t\t// we are not interested in the result\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tasync disconnect(): Promise<void> {\n\t\tthis.connection = {\n\t\t\turl: undefined,\n\t\t\tnamespace: undefined,\n\t\t\tdatabase: undefined,\n\t\t\ttoken: undefined,\n\t\t};\n\n\t\tawait this.ready?.catch(() => {});\n\t\tthis.socket?.close();\n\t\tthis.ready = undefined;\n\t\tthis.socket = undefined;\n\t\tthis.disconnected.resolve();\n\n\t\tawait Promise.any([\n\t\t\tthis.requireStatus(ConnectionStatus.Disconnected),\n\t\t\tthis.requireStatus(ConnectionStatus.Error),\n\t\t]);\n\t}\n\n\tasync rpc<\n\t\tMethod extends string,\n\t\tParams extends unknown[] | undefined,\n\t\tResult,\n\t>(\n\t\trequest: RpcRequest<Method, Params>,\n\t\tforce?: boolean,\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!force) await this.ready;\n\t\tif (!this.socket) throw new ConnectionUnavailable();\n\n\t\tlet res: RpcResponse | undefined = undefined;\n\t\twhile (!res) {\n\t\t\t// It's not realistic for the message to ever arrive before the listener is registered on the emitter\n\t\t\t// And we don't want to collect the response messages in the emitter\n\t\t\t// So to be sure we simply subscribe before we send the message :)\n\n\t\t\tconst id = getIncrementalID();\n\t\t\tconst response = this.emitter.subscribeOnce(`rpc-${id}`);\n\t\t\tthis.socket.send(this.encodeCbor({ id, ...request }));\n\t\t\tif (force && this.socket.readyState === WebSocket.CLOSED)\n\t\t\t\tthrow new EngineDisconnected();\n\n\t\t\tconst [raw] = await response;\n\t\t\tif (raw instanceof EngineDisconnected) throw raw;\n\t\t\tif (raw === RetryMessage) continue;\n\t\t\tres = raw;\n\t\t}\n\n\t\tif (\"result\" in res) {\n\t\t\tswitch (request.method) {\n\t\t\t\tcase \"use\": {\n\t\t\t\t\tconst [ns, db] = request.params as [\n\t\t\t\t\t\tstring | null | undefined,\n\t\t\t\t\t\tstring | null | undefined,\n\t\t\t\t\t];\n\n\t\t\t\t\tif (ns === null) this.connection.namespace = undefined;\n\t\t\t\t\tif (db === null) this.connection.database = undefined;\n\t\t\t\t\tif (ns) this.connection.namespace = ns;\n\t\t\t\t\tif (db) this.connection.database = db;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"signin\":\n\t\t\t\tcase \"signup\": {\n\t\t\t\t\tthis.connection.token = res.result as string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"authenticate\": {\n\t\t\t\t\tconst [token] = request.params as [string];\n\t\t\t\t\tthis.connection.token = token;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase \"invalidate\": {\n\t\t\t\t\tthis.connection.token = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res as RpcResponse<Result>;\n\t}\n\n\t// biome-ignore lint/suspicious/noExplicitAny: Cannot assume type\n\thandleRpcResponse({ id, ...res }: any): void {\n\t\tif (id) {\n\t\t\tthis.emitter.emit(`rpc-${id}`, [res]);\n\t\t} else if (res.error) {\n\t\t\tthis.setStatus(ConnectionStatus.Error, new ResponseError(res.error));\n\t\t} else {\n\t\t\tif (isLiveResult(res.result)) {\n\t\t\t\tconst { id, action, result } = res.result;\n\t\t\t\tthis.emitter.emit(`live-${id}`, [action, result], true);\n\t\t\t} else {\n\t\t\t\tthis.setStatus(\n\t\t\t\t\tConnectionStatus.Error,\n\t\t\t\t\tnew UnexpectedServerResponse({ id, ...res }),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tget connected(): boolean {\n\t\treturn !!this.socket;\n\t}\n\n\tasync export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.protocol = url.protocol.replace(\"ws\", \"http\");\n\t\turl.pathname = `${basepath}/export`;\n\n\t\tconst buffer = await this.req_post(options ?? {}, url, {\n\t\t\tAccept: \"plain/text\",\n\t\t});\n\n\t\tconst dec = new TextDecoder(\"utf-8\");\n\t\treturn dec.decode(buffer);\n\t}\n\n\tasync import(data: string): Promise<void> {\n\t\tif (!this.connection.url) {\n\t\t\tthrow new ConnectionUnavailable();\n\t\t}\n\t\tconst url = new URL(this.connection.url);\n\t\tconst basepath = url.pathname.slice(0, -4);\n\t\turl.protocol = url.protocol.replace(\"ws\", \"http\");\n\t\turl.pathname = `${basepath}/import`;\n\n\t\tawait this.req_post(data, url, {\n\t\t\tAccept: \"application/json\",\n\t\t});\n\t}\n}\n\nexport class Pinger {\n\tprivate pinger?: ReturnType<typeof setTimeout>;\n\tprivate interval: number;\n\n\tconstructor(interval = 30000) {\n\t\tthis.interval = interval;\n\t}\n\n\tstart(callback: () => void): void {\n\t\tthis.pinger = setInterval(callback, this.interval);\n\t}\n\n\tstop(): void {\n\t\tclearInterval(this.pinger);\n\t}\n}\n", "export interface Completable<T = void> {\n\tpromise: Promise<T>;\n\tresolve: (arg: T) => void;\n\treject: (reason?: Error) => void;\n\tcompleted: boolean;\n}\n\nexport function newCompletable<T = void>(): Completable<T> {\n\tconst out = {\n\t\tcompleted: false,\n\t} as Completable<T>;\n\tout.promise = new Promise<T>((resolve_, reject_) => {\n\t\tout.resolve = (arg: T) => {\n\t\t\tout.completed = true;\n\t\t\tresolve_(arg);\n\t\t};\n\t\tout.reject = (reason?: Error) => {\n\t\t\tout.completed = true;\n\t\t\treject_(reason);\n\t\t};\n\t});\n\treturn out;\n}\n", "export function rand(min: number, max: number): number {\n\treturn Math.random() * (max - min) + min;\n}\n", "import { ReconnectIterationError } from \"../errors\";\nimport type { Surreal } from \"../surreal\";\nimport { DEFAULT_RECONNECT_OPTIONS, type ReconnectOptions } from \"../types\";\nimport { rand } from \"./rand\";\n\nexport class ReconnectContext {\n\tprivate _attempts = 0;\n\treadonly options: ReconnectOptions;\n\treadonly surreal: Surreal;\n\n\t// Process options as passed by the user\n\tconstructor(\n\t\tinput: undefined | Partial<ReconnectOptions> | boolean,\n\t\tsurreal: Surreal,\n\t) {\n\t\tthis.surreal = surreal;\n\n\t\tif (!input) {\n\t\t\tthis.options = {\n\t\t\t\t...DEFAULT_RECONNECT_OPTIONS,\n\t\t\t\tenabled: false,\n\t\t\t};\n\t\t} else if (input === true) {\n\t\t\tthis.options = DEFAULT_RECONNECT_OPTIONS;\n\t\t} else {\n\t\t\tthis.options = {\n\t\t\t\t...DEFAULT_RECONNECT_OPTIONS,\n\t\t\t\t...input,\n\t\t\t};\n\t\t}\n\t}\n\n\tget attempts(): number {\n\t\treturn this._attempts;\n\t}\n\n\tget enabled(): boolean {\n\t\treturn this.options.enabled;\n\t}\n\n\tget allowed(): boolean {\n\t\t// Check if reconnecting is enabled\n\t\tif (!this.options.enabled) return false;\n\n\t\t// Check if the maximum number of attempts has been reached\n\t\tif (\n\t\t\tthis.options.attempts !== -1 &&\n\t\t\tthis._attempts >= this.options.attempts\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treset(): void {\n\t\tthis._attempts = 0;\n\t}\n\n\tasync iterate(): Promise<void> {\n\t\t// Restrict reconnect attempts and propagate ReconnectFailed error\n\t\tif (!this.allowed) {\n\t\t\tthrow new ReconnectIterationError();\n\t\t}\n\n\t\t// Bump iteration\n\t\tthis._attempts++;\n\n\t\t// Compute the next reconnect delay\n\t\tconst multiplier = this.options.retryDelayMultiplier ** this.attempts;\n\t\tconst adjustedDelay = this.options.retryDelay * multiplier;\n\t\tconst jitterModifier = rand(\n\t\t\t-this.options.retryDelayJitter,\n\t\t\tthis.options.retryDelayJitter,\n\t\t);\n\n\t\tconst nextDelay = Math.min(\n\t\t\tadjustedDelay * (1 + jitterModifier),\n\t\t\tthis.options.retryDelayMax,\n\t\t);\n\n\t\t// Wait for the next iteration\n\t\tawait new Promise<void>((r) => setTimeout(r, nextDelay));\n\t}\n}\n", "import {\n\tStringRecordId,\n\tTable,\n\ttype Uuid,\n\tRecordId as _RecordId,\n\tdecodeCbor,\n\tencodeCbor,\n} from \"./data\";\nimport {\n\ttype AbstractEngine,\n\tConnectionStatus,\n\tEngineContext,\n\ttype EngineEvents,\n\ttype Engines,\n} from \"./engines/abstract.ts\";\nimport { Emitter } from \"./util/emitter.ts\";\nimport { PreparedQuery } from \"./util/prepared-query.ts\";\nimport { versionCheck } from \"./util/version-check.ts\";\n\nimport type {\n\tActionResult,\n\tConnectOptions,\n\tExportOptions,\n\tLiveHandler,\n\tMapQueryResult,\n\tPatch,\n\tPrettify,\n\tQueryParameters,\n\tRpcResponse,\n} from \"./types.ts\";\n\nimport { AuthController } from \"./auth.ts\";\nimport { type Fill, partiallyEncodeObject } from \"./cbor\";\nimport { replacer } from \"./data/cbor.ts\";\nimport type { RecordIdRange } from \"./data/types/range.ts\";\nimport { HttpEngine } from \"./engines/http.ts\";\nimport { WebsocketEngine } from \"./engines/ws.ts\";\nimport {\n\tEngineDisconnected,\n\tNoActiveSocket,\n\tResponseError,\n\tSurrealDbError,\n\tUnsupportedEngine,\n} from \"./errors.ts\";\nimport { ReconnectContext } from \"./util/reconnect.ts\";\n\ntype R = Prettify<Record<string, unknown>>;\ntype RecordId<Tb extends string = string> = _RecordId<Tb> | StringRecordId;\n\nexport class Surreal extends AuthController {\n\tpublic connection: AbstractEngine | undefined;\n\tpublic emitter: Emitter<EngineEvents>;\n\n\tprotected engines: Engines = {\n\t\tws: WebsocketEngine,\n\t\twss: WebsocketEngine,\n\t\thttp: HttpEngine,\n\t\thttps: HttpEngine,\n\t};\n\n\tprivate _ready?: Promise<void> | undefined;\n\n\tconstructor({\n\t\tengines,\n\t}: {\n\t\tengines?: Engines;\n\t} = {}) {\n\t\tsuper();\n\t\tthis.emitter = new Emitter();\n\n\t\tif (engines) {\n\t\t\tthis.engines = {\n\t\t\t\t...this.engines,\n\t\t\t\t...engines,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Establish a socket connection to the database\n\t * @param connection - Connection details\n\t */\n\tasync connect(url: string | URL, opts: ConnectOptions = {}): Promise<true> {\n\t\tthis._ready = this.connectInner(url, opts);\n\t\tawait this._ready;\n\t\treturn true;\n\t}\n\n\tprivate async connectInner(\n\t\turl: string | URL,\n\t\topts: ConnectOptions = {},\n\t): Promise<void> {\n\t\tconst endpoint = parseUrl(url);\n\t\tconst engineName = endpoint.protocol.slice(0, -1);\n\t\tconst engine = this.engines[engineName];\n\t\tif (!engine) throw new UnsupportedEngine(engineName);\n\n\t\t// Process options\n\t\tconst { prepare, auth, namespace, database, reconnect } = opts;\n\n\t\t// Close any existing connections\n\t\tawait this.close();\n\n\t\t// We need to pass CBOR encoding and decoding functions as an argument to engines,\n\t\t// to ensure that everything is using the same instance of classes that these methods depend on.\n\t\tconst context = new EngineContext({\n\t\t\temitter: this.emitter,\n\t\t\tencodeCbor,\n\t\t\tdecodeCbor,\n\t\t\treconnect: new ReconnectContext(reconnect, this),\n\t\t\tprepare,\n\t\t});\n\n\t\t// The promise does not know if `this.connection` is undefined or not, but it does about `connection`\n\t\tconst connection = new engine(context);\n\n\t\t// If not disabled, run a version check\n\t\tif (opts.versionCheck !== false) {\n\t\t\tconst version = await connection.version(\n\t\t\t\tendpoint,\n\t\t\t\topts.versionCheckTimeout,\n\t\t\t);\n\t\t\tversionCheck(version);\n\t\t}\n\n\t\tthis.connection = connection;\n\n\t\tawait connection.connect(endpoint);\n\n\t\tif (namespace || database) {\n\t\t\tawait this.use({\n\t\t\t\tnamespace,\n\t\t\t\tdatabase,\n\t\t\t});\n\t\t}\n\n\t\tif (typeof auth === \"string\") {\n\t\t\tawait this.authenticate(auth);\n\t\t} else if (auth) {\n\t\t\tawait this.signin(auth);\n\t\t}\n\t}\n\n\t/**\n\t * Disconnect the socket to the database\n\t */\n\tasync close(): Promise<true> {\n\t\tthis.clean();\n\t\tawait this.connection?.disconnect();\n\t\treturn true;\n\t}\n\n\tprivate clean() {\n\t\t// Scan all pending rpc requests\n\t\tconst pending = this.emitter.scanListeners((k) => k.startsWith(\"rpc-\"));\n\t\t// Ensure all rpc requests get a connection closed response\n\t\tpending.map((k) => this.emitter.emit(k, [new EngineDisconnected()]));\n\n\t\t// Scan all active live listeners\n\t\tconst live = this.emitter.scanListeners((k) => k.startsWith(\"live-\"));\n\t\t// Ensure all live listeners get a CLOSE message with disconnected as reason\n\t\tlive.map((k) => this.emitter.emit(k, [\"CLOSE\", \"disconnected\"]));\n\n\t\t// Cleanup subscriptions and yet to be collected emisions\n\t\tthis.emitter.reset({\n\t\t\tcollectable: true,\n\t\t\tlisteners: [...pending, ...live],\n\t\t});\n\t}\n\n\t/**\n\t * Check if connection is ready\n\t */\n\tget status(): ConnectionStatus {\n\t\treturn this.connection?.status ?? ConnectionStatus.Disconnected;\n\t}\n\n\t/**\n\t * A promise which resolves when the connection is ready\n\t */\n\tget ready(): Promise<void> {\n\t\treturn Promise.all([this._ready, this.connection?.ready]).then(() => {});\n\t}\n\n\t/**\n\t * Ping SurrealDB instance\n\t */\n\tasync ping(): Promise<true> {\n\t\tconst { error } = await this.rpc(\"ping\");\n\t\tif (error) throw new ResponseError(error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Switch to a specific namespace and database.\n\t * @param database - Switches to a specific namespace.\n\t * @param db - Switches to a specific database.\n\t */\n\tasync use({\n\t\tnamespace,\n\t\tdatabase,\n\t}: {\n\t\tnamespace?: string | null;\n\t\tdatabase?: string | null;\n\t}): Promise<true> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\tif (namespace === null && database !== null)\n\t\t\tthrow new SurrealDbError(\n\t\t\t\t\"Cannot unset namespace without unsetting database\",\n\t\t\t);\n\t\tconst { error } = await this.rpc(\"use\", [namespace, database]);\n\t\tif (error) throw new ResponseError(error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Selects everything from the [$auth](https://surrealdb.com/docs/surrealql/parameters) variable.\n\t * ```sql\n\t * SELECT * FROM $auth;\n\t * ```\n\t * Make sure the user actually has the permission to select their own record, otherwise you'll get back an empty result.\n\t * @return The record linked to the record ID used for authentication\n\t */\n\tasync info<T extends R>(): Promise<ActionResult<T> | undefined> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T> | undefined>(\"info\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result ?? undefined;\n\t}\n\n\t/**\n\t * Specify a variable for the current socket connection.\n\t * @param key - Specifies the name of the variable.\n\t * @param val - Assigns the value to the variable name.\n\t */\n\tasync let(variable: string, value: unknown): Promise<true> {\n\t\tconst res = await this.rpc(\"let\", [variable, value]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Remove a variable from the current socket connection.\n\t * @param key - Specifies the name of the variable.\n\t */\n\tasync unset(variable: string): Promise<true> {\n\t\tconst res = await this.rpc(\"unset\", [variable]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn true;\n\t}\n\n\t/**\n\t * Start a live select query and invoke the callback with responses\n\t * @param table - The table that you want to receive live results for.\n\t * @param callback - Callback function that receives updates.\n\t * @param diff - If set to true, will return a set of patches instead of complete records\n\t * @returns A unique subscription ID\n\t */\n\tasync live<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(\n\t\ttable: RecordIdRange | Table | string,\n\t\tcallback?: LiveHandler<Result>,\n\t\tdiff?: boolean,\n\t): Promise<Uuid> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<Uuid>(\"live\", [table, diff]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\tif (callback) this.subscribeLive<Result>(res.result, callback);\n\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Subscribe to an existing live select query and invoke the callback with responses\n\t * @param queryUuid - The unique ID of an existing live query you want to receive updates for.\n\t * @param callback - Callback function that receives updates.\n\t */\n\tasync subscribeLive<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tthis.connection.emitter.subscribe(\n\t\t\t`live-${queryUuid}`,\n\t\t\tcallback as LiveHandler,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\t/**\n\t * Unsubscribe a callback from a live select query\n\t * @param queryUuid - The unique ID of an existing live query you want to ubsubscribe from.\n\t * @param callback - The previously subscribed callback function.\n\t */\n\tasync unSubscribeLive<\n\t\tResult extends Record<string, unknown> | Patch = Record<string, unknown>,\n\t>(queryUuid: Uuid, callback: LiveHandler<Result>): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tthis.connection.emitter.unSubscribe(\n\t\t\t`live-${queryUuid}`,\n\t\t\tcallback as LiveHandler,\n\t\t);\n\t}\n\n\t/**\n\t * Kill a live query\n\t * @param queryUuid - The query that you want to kill.\n\t */\n\tasync kill(queryUuid: Uuid | readonly Uuid[]): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\tif (Array.isArray(queryUuid)) {\n\t\t\tawait Promise.all(queryUuid.map((u) => this.rpc(\"kill\", [u])));\n\t\t\tconst toBeKilled = queryUuid.map((u) => `live-${u}` as const);\n\t\t\ttoBeKilled.map((k) => this.emitter.emit(k, [\"CLOSE\", \"killed\"]));\n\t\t\tthis.connection.emitter.reset({\n\t\t\t\tcollectable: toBeKilled,\n\t\t\t\tlisteners: toBeKilled,\n\t\t\t});\n\t\t} else {\n\t\t\tawait this.rpc(\"kill\", [queryUuid]);\n\t\t\tthis.emitter.emit(`live-${queryUuid}`, [\"CLOSE\", \"killed\"]);\n\t\t\tthis.connection.emitter.reset({\n\t\t\t\tcollectable: `live-${queryUuid}`,\n\t\t\t\tlisteners: `live-${queryUuid}`,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t */\n\tasync query<T extends unknown[]>(\n\t\t...args: QueryParameters\n\t): Promise<Prettify<T>> {\n\t\tconst raw = await this.queryRaw<T>(...args);\n\t\treturn raw.map(({ status, result }) => {\n\t\t\tif (status === \"ERR\") throw new ResponseError(result);\n\t\t\treturn result;\n\t\t}) as T;\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t */\n\tasync queryRaw<T extends unknown[]>(\n\t\t...[q, b]: QueryParameters\n\t): Promise<Prettify<MapQueryResult<T>>> {\n\t\tconst params =\n\t\t\tq instanceof PreparedQuery\n\t\t\t\t? [\n\t\t\t\t\t\tq.query,\n\t\t\t\t\t\tpartiallyEncodeObject(q.bindings, {\n\t\t\t\t\t\t\tfills: b as Fill[],\n\t\t\t\t\t\t\treplacer: replacer.encode,\n\t\t\t\t\t\t}),\n\t\t\t\t\t]\n\t\t\t\t: [q, b];\n\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<MapQueryResult<T>>(\"query\", params);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Runs a set of SurrealQL statements against the database.\n\t * @param query - Specifies the SurrealQL statements.\n\t * @param bindings - Assigns variables which can be used in the query.\n\t * @deprecated Use `queryRaw` instead\n\t */\n\tasync query_raw<T extends unknown[]>(\n\t\t...args: QueryParameters\n\t): Promise<Prettify<MapQueryResult<T>>> {\n\t\treturn this.queryRaw<T>(...args);\n\t}\n\n\t/**\n\t * Selects all records in a table, or a specific record, from the database.\n\t * If you intend on sorting, filtering, or performing other operations on the data, it is recommended to use the `query` method instead.\n\t * @param thing - The table name or a record ID to select.\n\t */\n\tasync select<T extends R>(thing: RecordId): Promise<ActionResult<T>>;\n\tasync select<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t): Promise<ActionResult<T>[]>;\n\tasync select<T extends R>(thing: RecordId | RecordIdRange | Table | string) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"select\", [thing]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Creates a record in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync create<T extends R, U extends R = T>(\n\t\tthing: RecordId | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"create\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param table - The table name to insert into.\n\t * @param data - The document(s) / record(s) to insert.\n\t */\n\tasync insert<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\tawait this.ready;\n\t\tconst [table, data] =\n\t\t\ttypeof arg1 === \"string\" || arg1 instanceof Table\n\t\t\t\t? [arg1, arg2]\n\t\t\t\t: [undefined, arg1];\n\t\tconst res = await this.rpc<ActionResult<T>>(\"insert\", [table, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document(s) / record(s) to insert.\n\t */\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insertRelation<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\tawait this.ready;\n\t\tconst [table, data] =\n\t\t\ttypeof arg1 === \"string\" || arg1 instanceof Table\n\t\t\t\t? [arg1, arg2]\n\t\t\t\t: [undefined, arg1];\n\t\tconst res = await this.rpc<ActionResult<T>>(\"insert_relation\", [\n\t\t\ttable,\n\t\t\tdata,\n\t\t]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Inserts one or multiple records in the database.\n\t * @param thing - The table name or the specific record ID to create.\n\t * @param data - The document(s) / record(s) to insert.\n\t * @deprecated Use `insertRelation` instead\n\t */\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\ttable: Table | string,\n\t\tdata?: U | U[],\n\t): Promise<ActionResult<T>[]>;\n\tasync insert_relation<T extends R, U extends R = T>(\n\t\targ1: Table | string | U | U[],\n\t\targ2?: U | U[],\n\t) {\n\t\treturn arg1 instanceof Table || typeof arg1 === \"string\"\n\t\t\t? this.insertRelation(arg1, arg2)\n\t\t\t: this.insertRelation(arg1);\n\t}\n\n\t/**\n\t * Updates all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function replaces the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to update.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync update<T extends R, U extends R = T>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"update\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Upserts all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function replaces the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to upsert.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync upsert<T extends R, U extends R = T>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"upsert\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Modifies all records in a table, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function merges the current document / record data with the specified data.***\n\t * @param thing - The table name or the specific record ID to change.\n\t * @param data - The document / record data to insert.\n\t */\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordId,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>>;\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: U,\n\t): Promise<ActionResult<T>[]>;\n\tasync merge<T extends R, U extends R = Partial<T>>(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"merge\", [thing, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Applies JSON Patch changes to all records, or a specific record, in the database.\n\t *\n\t * ***NOTE: This function patches the current document / record data with the specified JSON Patch data.***\n\t * @param thing - The table name or the specific record ID to modify.\n\t * @param data - The JSON Patch data with which to modify the records.\n\t */\n\tasync patch<T extends R>(\n\t\tthing: RecordId,\n\t\tdata?: Patch[],\n\t\tdiff?: false,\n\t): Promise<ActionResult<T>>;\n\tasync patch<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata?: Patch[],\n\t\tdiff?: false,\n\t): Promise<ActionResult<T>[]>;\n\tasync patch<T extends R>(\n\t\tthing: RecordId,\n\t\tdata: undefined | Patch[],\n\t\tdiff: true,\n\t): Promise<Patch[]>;\n\tasync patch<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t\tdata: undefined | Patch[],\n\t\tdiff: true,\n\t): Promise<Patch[][]>;\n\tasync patch(\n\t\tthing: RecordId | RecordIdRange | Table | string,\n\t\tdata?: Patch[],\n\t\tdiff?: boolean,\n\t) {\n\t\tawait this.ready;\n\n\t\t// biome-ignore lint/suspicious/noExplicitAny: Cannot assume type here due to function overload\n\t\tconst res = await this.rpc<any>(\"patch\", [thing, data, diff]);\n\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn diff ? res.result : output(thing, res.result);\n\t}\n\n\t/**\n\t * Deletes all records in a table, or a specific record, from the database.\n\t * @param thing - The table name or a record ID to select.\n\t */\n\tasync delete<T extends R>(thing: RecordId): Promise<ActionResult<T>>;\n\tasync delete<T extends R>(\n\t\tthing: RecordIdRange | Table | string,\n\t): Promise<ActionResult<T>[]>;\n\tasync delete<T extends R>(thing: RecordId | RecordIdRange | Table | string) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<ActionResult<T>>(\"delete\", [thing]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Obtain the version of the SurrealDB instance\n\t * @example `surrealdb-2.1.0`\n\t */\n\tasync version(): Promise<string> {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc<string>(\"version\");\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Run a SurrealQL function\n\t * @param name - The full name of the function\n\t * @param args - The arguments supplied to the function. You can also supply a version here as a string, in which case the third argument becomes the parameter list.\n\t */\n\tasync run<T>(name: string, args?: unknown[]): Promise<T>;\n\t/**\n\t * Run a SurrealQL function\n\t * @param name - The full name of the function\n\t * @param version - The version of the function. If omitted, the second argument is the parameter list.\n\t * @param args - The arguments supplied to the function.\n\t */\n\tasync run<T>(name: string, version: string, args?: unknown[]): Promise<T>;\n\tasync run(name: string, arg2?: string | unknown[], arg3?: unknown[]) {\n\t\tawait this.ready;\n\t\tconst [version, args] = Array.isArray(arg2)\n\t\t\t? [undefined, arg2]\n\t\t\t: [arg2, arg3];\n\n\t\tconst res = await this.rpc(\"run\", [name, version, args]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn res.result;\n\t}\n\n\t/**\n\t * Obtain the version of the SurrealDB instance\n\t * @param from - The in property on the edge record\n\t * @param thing - The id of the edge record\n\t * @param to - The out property on the edge record\n\t * @param data - Optionally, provide a body for the edge record\n\t */\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: RecordId,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t): Promise<T>;\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: string,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t): Promise<T[]>;\n\tasync relate<T extends R, U extends R = T>(\n\t\tfrom: string | RecordId | RecordId[],\n\t\tthing: string | RecordId,\n\t\tto: string | RecordId | RecordId[],\n\t\tdata?: U,\n\t) {\n\t\tawait this.ready;\n\t\tconst res = await this.rpc(\"relate\", [from, thing, to, data]);\n\t\tif (res.error) throw new ResponseError(res.error.message);\n\t\treturn output(thing, res.result);\n\t}\n\n\t/**\n\t * Send a raw message to the SurrealDB instance\n\t * @param method - Type of message to send.\n\t * @param params - Parameters for the message.\n\t */\n\tpublic rpc<Result>(\n\t\tmethod: string,\n\t\tparams?: unknown[],\n\t): Promise<RpcResponse<Result>> {\n\t\tif (!this.connection) throw new NoActiveSocket();\n\n\t\treturn this.connection.rpc<typeof method, typeof params, Result>({\n\t\t\tmethod,\n\t\t\tparams,\n\t\t});\n\t}\n\n\t/**\n\t * Export the database and return the result as a string\n\t * @param options - Export configuration options\n\t */\n\tpublic async export(options?: Partial<ExportOptions>): Promise<string> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\treturn this.connection.export(options);\n\t}\n\n\t/**\n\t * Import an existing export into the database\n\t * @param input - The data to import\n\t */\n\tpublic async import(input: string): Promise<void> {\n\t\tawait this.ready;\n\t\tif (!this.connection) throw new NoActiveSocket();\n\t\treturn this.connection.import(input);\n\t}\n}\n\ntype Output<T, S> = S extends RecordId ? T : T[];\nfunction output<T, S>(subject: S, input: T | T[]): Output<T, S> {\n\tconst one = subject instanceof _RecordId || subject instanceof StringRecordId;\n\tif (one) return (Array.isArray(input) ? input[0] : input) as Output<T, S>;\n\treturn (Array.isArray(input) ? input : [input]) as Output<T, S>;\n}\n\nfunction parseUrl(value: string | URL): URL {\n\tconst url = new URL(value);\n\n\tif (!url.pathname.endsWith(\"/rpc\")) {\n\t\tif (!url.pathname.endsWith(\"/\")) url.pathname += \"/\";\n\t\turl.pathname += \"rpc\";\n\t}\n\n\treturn url;\n}\n\nfunction rand(min: number, max: number) {\n\treturn Math.random() * (max - min) + min;\n}\n"],
  "mappings": "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",
  "names": ["WebSocket", "replacer", "input", "s", "f", "r", "arr", "decode", "id", "output", "textEncoder", "version", "ConnectionStatus", "encodeCbor", "decodeCbor", "resolve", "reject", "WebSocket", "u"]
}
